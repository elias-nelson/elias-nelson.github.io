[
  {
    "objectID": "software/software.html",
    "href": "software/software.html",
    "title": " Software & Data",
    "section": "",
    "text": "I am developing specialized software for users who work exclusively with the R programming language. I still have a lot to learn, so at first I expect to publish data packages I also have some good ideas for more complex packages, but I plan to work on those in 2026‚Ä¶ üòÄ\n\n\n    \n    \n    \n      \n      \n        \n          \n        \n        \n          The R package greekElectionsR provides data related to the Greek parliament from 1981 to 2019. Through the package, you can find information about the elected members of parliament for each period, the election results, and the votes of the elected presidents of the parliament.\n          \n             Repository\n          \n        \n    \n\n\nNo matching items"
  },
  {
    "objectID": "software/software.html#r-packages",
    "href": "software/software.html#r-packages",
    "title": " Software & Data",
    "section": "",
    "text": "I am developing specialized software for users who work exclusively with the R programming language. I still have a lot to learn, so at first I expect to publish data packages I also have some good ideas for more complex packages, but I plan to work on those in 2026‚Ä¶ üòÄ\n\n\n    \n    \n    \n      \n      \n        \n          \n        \n        \n          The R package greekElectionsR provides data related to the Greek parliament from 1981 to 2019. Through the package, you can find information about the elected members of parliament for each period, the election results, and the votes of the elected presidents of the parliament.\n          \n             Repository\n          \n        \n    \n\n\nNo matching items"
  },
  {
    "objectID": "software/software.html#scraping-projects",
    "href": "software/software.html#scraping-projects",
    "title": " Software & Data",
    "section": "Scraping Projects",
    "text": "Scraping Projects\nData analysis requires data. However, it is rare that everything we want is freely available and organized. So we have to extract the necessary information from various sources. These are some projects where I extract data from various websites in order to analyze it in some of my articles. If you are interested in any of the data sets below, you can download them and perform your own analysis without needing to use R. You can also read the corresponding article for more technical details."
  },
  {
    "objectID": "posts/intro-to-r/index.html",
    "href": "posts/intro-to-r/index.html",
    "title": "An Introduction to R",
    "section": "",
    "text": "AI Generated"
  },
  {
    "objectID": "posts/intro-to-r/index.html#introduction",
    "href": "posts/intro-to-r/index.html#introduction",
    "title": "An Introduction to R",
    "section": "1 Introduction",
    "text": "1 Introduction\nA few months into using  for data analysis, I had a lightbulb moment‚ÄîI didn‚Äôt actually know what  was. Sure, I could write some code and get results (output), but that didn‚Äôt mean I truly understood what  could do or how powerful it really is. I realized I never had a proper introduction to the language.\nOften, experts skip over details they assume are ‚Äòobvious‚Äô‚Äîbut things are only obvious once you‚Äôre familiar with them. In my case, I felt like I‚Äôd been thrown into the deep end with , missing the foundational understanding that would have made everything else click.\nDespite this rocky start, my passion to learn  didn‚Äôt wane. Over time, I‚Äôve come to see how much the way you‚Äôre introduced to  shapes your experience, especially if you‚Äôre used to point-and-click software (GUIs) and are now stepping into the world of command-line interfaces (CLIs) and scripting.\nThat‚Äôs why, after navigating my own struggles, I decided to write this comprehensive guide. It‚Äôs meant for absolute beginners (and if the term ‚Äòabsolute beginner‚Äô feels a little harsh, I apologize‚Äîbut it answers the question: Who is this for?). I hope it will also help those who already have some  experience but feel like they missed out on key concepts during their own introductions to the language.\nI won‚Äôt promise that you‚Äôll become an  programming guru overnight after reading this guide, but by the end of it, you should be able to:\n\nInstall  and set up an IDE (Integrated Development Environment) to work in.\nRun R commands and use the language with confidence.\nLoad and utilize  packages effectively.\nImport data into the  environment.\nClean and manipulate data for more efficient analysis.\nUnderstand basic data types and structures in  e.g., vectors, lists, and data frames.\nWrite your own R functions and scripts.\nUse the power of  to perform some basic statistical analysis and data-processing tasks.\nAppreciate the meaning of the following code:\n\n\ninvisible(\n  lapply(\n    pkgs,\n    library\n  )\n)\n\n\nCreate beautiful graphs and visualizations to bring your data to life.\nKnow where to find additional help and resources to improve your  coding skills."
  },
  {
    "objectID": "posts/intro-to-r/index.html#overview-of",
    "href": "posts/intro-to-r/index.html#overview-of",
    "title": "An Introduction to R",
    "section": "2 Overview of ",
    "text": "2 Overview of \n\n2.1 What is ?\nAt first glance, ‚ÄúWhat is ?‚Äù may seem like a simple question, but as Zuur, Ieno, and Meesters (2009); point out, it‚Äôs not so easily answered‚Äîand I agree. Broadly defined,  is a computer language that allows users to program algorithms and use tools that others have developed. This is a fairly generalized description and could apply to the plethora of programming languages, but  stands out because it‚Äôs often defined as a powerful environment specifically designed for statistical computing and graphics‚Äîor more simply, a statistical programming language.\nIt was developed by Ross Ihaka and Robert Gentleman as a free software environment for teaching, while they were colleagues at the University of Auckland in New Zealand (Vries and Meys 2012). Their goal was to create an intuitive system for statistical computing and data visualization‚Äîsomething that statisticians across the world could adopt with ease. Given its origins,  is exceptionally well-suited for data science, a vital field in today‚Äôs world‚Äî developed by statisticians for statisticians. In fact,  is often referred to as the ‚Äúlingua franca of statistics‚Äù among statisticians and scientists.\nA more practical way to understand , however, is by looking at what it can do. As I‚Äôve often told colleagues and friends, ‚Äú can do anything you can imagine,‚Äù and that‚Äôs hardly an exaggeration. With , you can:\n\nWrite custom functions and perform calculations\nApply nearly every available statistical technique\nGenerate everything from simple to highly complex graphs\nPerform geocomputation and geostatistics (Lovelace, Nowosad, and Muenchow 2019)\nCreate stunning 3D visualizations (Morgan-Wall 2024)\nDevelop your own libraries of reusable functions\n\nPerhaps one of the most significant, nontrivial reasons for its widespread use is that  is free of charge, supported by a vast, active user community.\nSo Why Isn‚Äôt Everyone Using ?\nThis question is easier to answer:  has a notoriously steep learning curve. Since it relies heavily on programming, even though there are graphical user interfaces (GUIs) available, none are advanced enough to fully eliminate the need for coding. But once you get the hang of , I reckon you‚Äôll find it hard to return to any other software for statistical computing.\nFrom my own experience‚Äîand from hearing others share theirs‚Äîlearning both  and statistics simultaneously can feel overwhelming, like climbing two steep hills at once. Zuur, Ieno, and Meesters (2009), also acknowledge this issue, noting that when  is taught alongside statistics, many learners tend to focus on simply getting the  code to run, and often overlooking the weightier statistical concepts behind it. I faced the same struggle when I was first introduced to .\nThat‚Äôs why this post focuses primarily on providing basic  instructions and not diving too deeply into statistics. However, I will demonstrate some fundamental statistical procedures you can perform in  later in the post. If your goal is to learn both R and statistics, this guide will provide the foundation you need to master , equipping you with the skills to explore its powerful statistical tools and the vast range of packages that extend its capabilities.\n\n\n2.2 Historical Background of \n is a modern implementation, or dialect, of an earlier programming language called S (Becker, Chambers, and Wilks 2018). It also incorporates lexical scoping semantics inspired by Scheme The development of  began in 1991, when Professors Ross Ihaka and Robert Gentleman at the University of Auckland, New Zealand, recognized the need for a better software environment for their Macintosh teaching laboratory. Their journey into developing  is detailed in a 1996 paper in the Journal of Computational and Graphical Statistics (Ihaka and Gentleman 1996).\nThe name ‚ÄúR‚Äù is a nod to both the first names of its authors (Ross and Robert) and a playful reference to its predecessor, S. By 1993, after they had made significant progress, Ihaka and Gentleman began to share their work more widely, distributing binary copies of `{{&lt; fa brands r-project &gt;}} through the StatLib data archive and announcing it on the s-news mailing list.\nInterest in  quickly grew, and many began to collaborate with the duo‚Äîmost notably, Martin M√§chler from ETH Zurich. In June 1995, M√§chler convinced Ihaka and Gentleman to release  as free and open-source software under the terms of the Free Software Foundation‚Äôs GNU General Public License, allowing anyone to use and modify it freely. Initially, bug reports were sent via email, but as interest surged, it became clear that manually maintaining communication was unsustainable. In response, in March 1996, M√§chler volunteered the facilities at ETH Zurich to set up the r-testers mailing list, which allowed for automated discussions about  and its development.\nApproximately a year later, r-testers was replaced by three newsgroups: R-announce, R-help, and R-devel. Over time, more mailing lists were added to accommodate the growing community. Currently, the  project maintains five general mailing lists, including R-package-devel and R-packages, which can be found at https://www.r-project.org/mail.html.\nToday, the R Core Team‚Äîa group of currently 18 active individuals‚Äîhas write access to the  source code (https://www.r-project.org/contributors.html), guiding its ongoing development. Many others have also contributed through new code submissions and bug fixes, making R a true collaborative effort. For those interested in a more detailed account of R‚Äôs development, Ross Ihaka provides a fascinating overview, available at http:// cran.r‚Äêproject.org/doc/html/ interface98‚Äêpaper/paper.html.\nThe Comprehensive R Archive Network (CRAN) was officially launched on 23 April 1997, providing a centralized platform to store R‚Äôs executable files, source code, documentation, and packages. Over time, CRAN has grown into one of the most extensive repositories for data science tools. In April 2003, the R Foundation was founded as a non-profit organization to provide long-term support for ‚Äôs continued development, ensuring that it remains a leading tool for statistical computing and data visualization.\nSince its humble beginnings,  has grown into a global force in statistical computing and data science. Thanks to its open-source nature and a thriving community, it remains one of the most widely used and rapidly evolving tools for data analysis. As the field of data science expands, ‚Äôs importance continues to grow, cementing its place as an indispensable resource for statisticians, data scientists, and researchers alike."
  },
  {
    "objectID": "posts/intro-to-r/index.html#getting-started-with-programming",
    "href": "posts/intro-to-r/index.html#getting-started-with-programming",
    "title": "An Introduction to R",
    "section": "3 Getting Started With  Programming",
    "text": "3 Getting Started With  Programming\nEvery journey begins with gathering the right tools, and your adventure into  programming is no different. The first essential step for any  novice is setting up the environment to start coding. Essentially, you have two main options:\n\nInstall  and an IDE such as RStudio, VS Code or Positron\nRun  in a browser, for example, via RStudio Cloud.\n\nWhile installing  along with an IDE like RStudio, VS Codeor Positron requires a little more time and effort, it offers a more robust setup‚Äîallowing offline work and leveraging your computer‚Äôs CPU‚ÄîI highly recommend this approach, especially for those committed to diving deep into . However, if you‚Äôre just exploring or testing the waters, running  online through platforms like RStudio Cloud may be more convenient (provided you have a reliable internet connection).\nWhichever path you choose, this post is designed to accommodate you. Whether you install  locally or use an online platform, the examples and instructions provided here will guide you seamlessly through your  programming journey.\n\n3.1 Downloading and Installing \nNow that we‚Äôve covered an overview of  and some of its history, it‚Äôs time to get your own copy of  so you can start using it. The easiest way to do this is by downloading a precompiled binary distribution of R, which includes the base system and contributed packages, and installing it on your computer. While it‚Äôs also possible to install  from source, this is more complex and generally not necessary for most users. I recommend sticking to the precompiled binaries, which are easy to install and are available for a range of operating systems, including Windows, macOS, and Linux. In this guide, we‚Äôll focus on installing R on Windows and macOS.\n\n3.1.1 Installing  on Windows\nInstalling  on Windows is a straightforward process. Here‚Äôs a step-by-step guide:\n\nGo to the CRAN website: Visit the Comprehensive R Archive Network (CRAN) at https://cran.r-project.org/.\nDownload R for Windows: Click on the ‚ÄúDownload R for Windows‚Äù link.\n\n\n\n\n\n\n\nDownload the base system: On the next page, click ‚Äúbase‚Äù or ‚ÄúInstall R for the first time‚Äù to download the R executable file (e.g., R-4.x.x-win.exe).\nRun the R installer: Once downloaded, double-click the executable file to start the installation process. You may be prompted to allow the application to make changes to your device‚Äîclick ‚ÄúYes‚Äù to continue.\nSelect installation language: The installer will first prompt you to select the installation language. Choose your preferred language and click ‚ÄúOK‚Äù.\n\n\n\n\n\n\n\nLicense agreement: You‚Äôll see a window with the GNU General Public License information. Simply click ‚ÄúNext‚Äù.\n\n\n\n\n\n\n\nChoose the destination location: By default, R will install in C:\\Program Files\\R\\R-4.x.x. Unless you have a specific reason to change it, I recommend leaving this as is and clicking ‚ÄúNext‚Äù.\n\n\n\n\n\n\n\nSelect components: In the ‚ÄúSelect Components‚Äù window, the default options should suffice for most users, so just click ‚ÄúNext‚Äù.\n\n\n\n\n\n\n\nStartup options: Again, leave the default startup options selected and click ‚ÄúNext‚Äù.\n\n\n\n\n\n\n\nSelect Start Menu folder: The default Start Menu folder is fine, so just click ‚ÄúNext‚Äù here as well.\n\n\n\n\n\n\n\nAdditional tasks: The installer will ask if you‚Äôd like to create desktop shortcuts or add R to your system PATH. The default options are usually best, so leave them checked and click ‚ÄúNext‚Äù.\n\n\n\n\n\n\n\nBegin installation: After confirming all the settings, click ‚ÄúNext‚Äù to start the installation process.\n\n\n\n\n\n\n\nComplete installation: Once the installation is complete, click ‚ÄúFinish‚Äù to close the installer.\n\n\n\n\n\n\nCongratulations, you‚Äôve successfully installed  on your Windows system!\n\n\n3.1.2 Installing  on macOS\nThe installation process for macOS is very similar to that of Windows, but with a few differences in file format. Follow these steps:\n\nGo to the CRAN website: Head over to https://cran.r-project.org/.\nDownload R for macOS: Click on ‚ÄúDownload R for macOS‚Äù.\nChoose the latest release: In the ‚ÄúLatest release‚Äù section, download the appropriate version of  for your macOS system.\n\n\n\n\n\n\n\nOpen the installer: Once the download is complete, double-click the .pkg installer file to open it.\nFollow the installation prompts: Click ‚ÄúContinue‚Äù and proceed through the installer by following the on-screen instructions.\nComplete installation: Once the installation process finishes, click ‚ÄúClose‚Äù to exit the installer.\n\nYou now have  installed on your macOS system!\nWith these steps completed, you‚Äôre ready to start programming in ! Next, we‚Äôll move on to setting up a suitable Integrated Development Environment (IDE) to enhance your experience with .\n\n\n\n3.2 Exploring IDE Options for : Elevate Your  Programming with RStudio, VS Code, or Positron\n\n3.2.1 Getting Started With the  Interface\nWhen working with , several user interfaces (UIs) are available, but every installation of  includes a basic/standard interface‚Äîsometimes called the ‚ÄúR Console.‚Äù While you may eventually prefer using an advanced IDE like RStudio, it‚Äôs important to familiarize yourself with this standard interface. Not only can it be helpful when using a machine without your preferred or favorite interfaces, but it also serves as a good foundation for understanding how other interfaces are organized. You may even come to appreciate and enjoy the simplicity of the standard interface.\nWhat follows is a practical guide on using the RGUI, which is the standard graphical interface for  on Windows platforms.\nOn Windows,  is typically installed in C:\\Program Files\\R, and you can access it from the Start menu under the  group. If, during installation, you selected ‚ÄúCreate a desktop shortcut,‚Äù you‚Äôll also have an RGUI icon on your desktop. To launch , simply double-click this icon, and you‚Äôll be greeted by a user interface that looks something like this:\n\n\n\n\n\nWhen opened, the main window, labeled ‚ÄúR Console,‚Äù will appear. This is where you will enter and execute your  commands. You can type commands directly into the Console and see the output immediately. This is also where error messages appear, . Keep in mind, closing the Console will end your  session.\nThe main window of RGUI is the ‚ÄúR Console,‚Äù which automatically opens when you launch . This Console is where you enter  commands one at a time. Depending on the command, the output will be displayed in the Console, and this is also where any error messages will appear. The Console is unique and it‚Äôs the primary space for interacting with ‚Äîkeep in mind, closing the Console will end your  session.\n\n\n\n\n\n\nNoteIsn‚Äôt  a Language?\n\n\n\nYou might hear me refer to  as if it were a person, saying things like ‚ÄúTell  to do this‚Äù or ‚ÄúTell  to do that.‚Äù But, of course,  can‚Äôt do anything‚Äîit‚Äôs just a language. This is simply shorthand for saying, ‚ÄúInstruct your computer to perform a task by writing a command in the  language in the R console.‚Äù It‚Äôs your computer, not  itself, that does the heavy lifting.\nIs this shorthand a bit imprecise and lazy? Yes. But does everyone still use it? Absolutely‚Äîbecause it‚Äôs convenient and saves time!\n\n\nFor new users, the easiest way to save the Console‚Äôs contents is to navigate to File ‚Üí Save to file from the menu. However, note that the Console only retains the last few thousand lines written to it, so it‚Äôs wise to save important work elsewhere. You may also find it helpful to clear the Console to start fresh. To do this, simply press Ctrl + L or select Edit ‚Üí Clear console from the menu.\nReady to Write Your First Program in ?\nNow that we have  installed and running, let‚Äôs dive right in by writing our first simple computer program. To do this, open  (if it‚Äôs not already open), and in the ‚ÄúR Console‚Äù type the following code after the &gt; prompt symbol, then press Enter‚Üµ:\n\nprint(\"Hello, World!\")\n\nAfter pressing Enter‚Üµ, you should see the following output appear in the Console, as shown in the image below.\n\n\n\n\n\nCongratulations!‚Äîyou‚Äôve just written a computer program! A computer program is simply a sequence of instructions that perform a specific task when executed by the computer. The ‚ÄúHello, World!‚Äù program is a classic way to introduce novice programmers to a new language. It serves two purposes: demonstrating the basic syntax of the language and verifying that the installation was successful, ensuring you know how to use it. In this case, the program consists of just one instruction‚Äîthe command to display the text ‚ÄúHello, World!‚Äù in the console. The command responsible for this is print().\nA couple of things to note about your first program:\n\n‚ÄúHello, World!‚Äù is a string: A string is a way of representing text in a computer program. In , a string must be enclosed in quotes (' ' or \" \"), which act as delimiters, signaling where the string starts and ends. The text inside the quotes‚ÄîHello, World!‚Äîis the actual string.\nprint is a function: Just like in mathematics, a function in  takes input, performs an operation, and returns output. The print function‚Äôs job is to take its input (in this case, the string \"Hello, World!\") and display it in the console in a readable format.\nCalling a function: To execute the function, you need to ‚Äúcall‚Äù it, which is done by following the function name (print) with a pair of parentheses. The input to the function, in this case, the string, goes inside the parentheses. The parentheses are important as they tell  where the input starts and ends, serving as another type of delimiter.\n\nLet‚Äôs try another simple program with a basic arithmetic calculation‚Äîyes,  can function like a calculator. You can:\n\nAdd numbers with +\nSubtract with -\nMultiply with *\nDivide with /\nRaise numbers to a power with ^\n\nType the following code into the console and press Enter‚Üµ:\n\nprint(4 + 2)\n\nAfter pressing Enter‚Üµ, you should see the following output in the console:\n\n\n\n\n\nSo far, we‚Äôve been using the print() function to display output. However, you can actually get output in the console without explicitly calling print(). You don‚Äôt always need the print() function for simple outputs. Typing just the expression will display the result:. For example, suppose you type:\n\n\"Hello, World!\"\n\nIn the console, you‚Äôll see the following result:\n\n\n\n\n\nSimilarly, you can try:\n\n2 + 2\n\nwith the output:\n\n\n\n\n\n\n\n\n\n\n\nImportantRead-Evaluate-Print Loop (REPL)\n\n\n\nSo far, you‚Äôve been using  in what computer scientists call interactive mode. This means you type a command into the console, R immediately reads it, evaluates it, and prints the result back to the console for you to see. Then, you type the next command, and the process repeats. This cycle is known as the Read-Evaluate-Print Loop, or REPL for short.\n, like other interactive languages, excels at providing immediate feedback, which makes it especially useful for statisticians and data analysts who often run small procedures, check results, and refine their approach iteratively‚Äîafter all, R was originally designed by statisticians, for statisticians. As beginners, the REPL offers a fantastic way to observe ‚Äôs behavior and receive instant feedback on the simple programs we‚Äôre writing, helping us quickly understand how R processes our commands.\n\n\n\n\n\n\n\n\nTipWhen Do We Compile?\n\n\n\nIn some languages, like C, Java, or FORTRAN, you need to compile your human-readable code into machine-readable code (typically in the form of 1s and 0s) before it can be executed. If you‚Äôve worked with those languages before, you might wonder whether you need to compile your  code too. The answer is no‚ÄîR is a dynamic programming language, meaning it automatically interprets your code on the fly as you run it, without the need for a separate compilation step.\n\n\nBelow I have included an interactive webR REPL console for more engagement right here on this page especially for those who may only want to test the water‚Äôs of . Feel free to execute the examples we‚Äôve doe above.\n\n\n\n  Loading webR, please wait‚Ä¶\n\n\n\n  \n  Run\n\n\n\n\n\n\nInput code in the input box and click Run to send the command to the interactive console.\n\n¬†\nThe ‚ÄúR Editor‚Äù Window:\nFor more complex programs, you‚Äôll want to work in the ‚ÄúR Editor,‚Äù where you can write and edit multiple lines of code. When you‚Äôre ready to move beyond typing and executing commands one by one, you can use the ‚ÄúR Editor‚Äù window to write and manage scripts efficiently. To open a blank editor, click File ‚Üí New Script from the menu. If you have an existing script, select File ‚Üí Open Script to continue working on it. The image below shows a new blank ‚ÄúR Editor‚Äù window.\n\n\n\n\n\nYou can have multiple ‚ÄúR Editor‚Äù windows open simultaneously, allowing you to work on different scripts side by side.\n\n\n\n\n\n\nNote\n\n\n\nThe available menus and toolbar options change based on which window is currently in focus. In the image above, the focus has shifted from the ‚ÄúR Console‚Äù to the ‚ÄúR Editor,‚Äù which is why the toolbar and menu options have updated accordingly.\n\n\nAs expected, the script editor allows you to run commands either individually or in groups. You can also execute part of an expression by highlighting the code and pressing Ctrl + R (or using the ‚ÄúRun line or selection‚Äù button in the toolbar, or clicking Edit ‚Üí Run line or selection¬†from the menu).\n\nTo run a single line of code, place the cursor within the line you want to execute and press Ctrl + R. Note that one line may not always be a complete executable statement.\nTo run a specific section of code, highlight the desired text and press Ctrl + R. The highlighted text can span multiple lines or just part of one.\nTo run the entire script, highlight everything using Ctrl + A and then press Ctrl + R.\n\nYou can save your script anytime by pressing Ctrl + S or selecting File ‚Üí Save.\nThe ‚ÄúR Graphics‚Äù Window:\nWhen you utilize a function such as plot() to create a graphic, the graphics window‚Äîcommonly referred to as the ‚Äúdevice‚Äù‚Äîserves as the default output area. If a graphics window is not already open, a new one is produced, otherwise the existing window is reused.\nTo illustrate this, let‚Äôs plot a graph using a built-in dataset called pressure. The dataset, which comes pre-installed with , shows the relationship between temperature (in degrees Celsius) and vapor pressure of mercury (measured in millimeters). Below, we apply the plot() function to the pressure dataset and execute it from the ‚ÄúR Editor‚Äù:\n\n\n\n\n\nTo open a new graphics window without closing an existing one, you can use the dev.new() function. This allows you to create multiple graphics windows for your visualizations. To save a graphic, simply click File ‚Üí Save As and select your desired format from the menu.\nThe ‚ÄúData Editor‚Äù Window:\nThe simplest way to examine the contents of a basic data object is by printing it directly to the Console. Just type the object‚Äôs name at the command prompt.\nTo explore the data within a data frame or matrix, you can use either fix(dataframe) or View(dataframe), where ‚Äúdataframe‚Äù refers to the name of your data object. These functions are specifically for data frames and matrices. The fix() function allows you to modify the data, while View() only displays it without editing capabilities. Alternatively, you can navigate to Edit ‚Üí Data Editor in the menu and specify the name of the data frame or matrix you wish to edit.\nAs an example, let‚Äôs view the pressure dataset we used earlier to plot the graph. You can use the following command:\n\nfix(pressure)\n\n\n\n\n\n\nThis will open the data frame in a tab where you can inspect it interactively.\nAny changes you make using the Data Editor are automatically saved to your workspace (you‚Äôll learn more about saving the workspace later). However, while the Data Editor is open, you cannot run any other code, and files cannot be saved directly from this window.\nThe ‚ÄúR History‚Äù Window:\nYou can access your command history by using the history() function, which opens a window displaying your most recent commands. By default, this shows the last 25 lines of code you‚Äôve submitted. Below is an example of what my current history looks like.\n\n\n\n\n\nTo save the contents of this history window, you can either click File ‚Üí Save to file in the menu or use the savehistory() function directly in the Console. This allows you to preserve your previous commands for future reference or reuse.\nSaving the Workspace\n stores the data and objects you‚Äôre working with in an area of your computer‚Äôs memory called the ‚Äúworkspace.‚Äù While the standard R interface doesn‚Äôt have a dedicated window to display these objects, you can easily list them in the Console by using the ls() function. These objects can include data imported from external sources (such as text files), new data you‚Äôve generated, results from expressions you‚Äôve executed, and various other elements.\nWhen you shut down R, it will typically prompt you to save your workspace. If you choose to save it under the default name .RData (note that it‚Äôs just the file extension with no filename),  will automatically load this workspace the next time you launch it.\nFor substantial work, it‚Äôs generally considered good practice to save your raw data sources and a script that recreates your data objects. This ensures that you‚Äîor anyone else‚Äîcan fully reproduce your analysis. From this perspective, it‚Äôs often unnecessary to save the workspace itself.\nHowever, if your work involves lengthy data processing or a complex script, saving the workspace can be useful as it provides a convenient starting point for your next session, saving time and effort.\nTo save your workspace, either click File ‚Üí Save workspace in the menu, or use the save.image() function in the Console. If you want to save it under a specific filename, use save(file = \"filename\"). You can load a previously saved workspace by running load(file = \"filename\").\nSo far, we‚Äôve successfully interacted with base ‚Äîwe‚Äôve written our first ‚ÄúHello, World!‚Äù program, performed basic arithmetic, and even plotted a graph (how cool is that?). While RGUI is functional, it can feel somewhat basic and limited compared to modern integrated development environments (IDEs), which offer enhanced features for coding, debugging, and data visualization. In the next section, we will explore the powerful capabilities provided by IDEs.\n\n\n3.2.2 RStudio IDE for  and  python\nOne of the most popular ways to interface with , beyond the basic RGUI, is through RStudio, a powerful Integrated Development Environment (IDE) designed primarily for . RStudio offers an intuitive and interactive environment, making coding, data analysis, and project management significantly easier. However, it‚Äôs important to note that before using RStudio, you must first install  on your computer.\nAccording to RStudio‚Äôs mission statement:\n\n‚ÄúTo create free and open-source software for data science, scientific research, and technical communication. We do this to enhance the production and consumption of knowledge by everyone, regardless of economic means, and to facilitate collaboration and reproducible research, both of which are critical to the integrity and efficacy of work in science, education, government, and industry.‚Äù\n\nRStudio was founded by J.J. Allaire, a software engineer and entrepreneur, in 2009, with the first version of RStudio IDE released in 2011. Since its release, RStudio has become a go-to tool for data scientists, researchers, and statisticians worldwide.\nWhile RStudio is mainly known for its support of , it also accommodates other programming languages, such as Python, SQL, and even Stan for Bayesian statistics. This flexibility makes RStudio a multi-functional open-source IDE that is widely adopted for various programming and data analysis needs. RStudio works best with  versions 3.0.1 and higher, ensuring compatibility with most modern workflows.\n\nVisit Posit, the official RStudio website to download RStudio Desktop.\nOn the homepage, expand the \"FREE & OPEN SOURCE\" Tab and look under the \"Analyze & Explore\" section.\nClick \"RSTUDIO IDE\" (or simply select \"DOWNLOAD RSTUDIO\" at the bottom of the list. If you choose \"DOWNLOAD RSTUDIO\", you can skip to step 4).\n\n\n\n\n\n\n\n\n\n\nThis will take you to the RStudio IDE page.\nChoose between RStudio Desktop (free) and RStudio Desktop Pro (Paid).\nOn the RStudio IDE page, you will see two editions as you scroll down the page:\n\nRStudio Desktop ‚Äì Free (Open Source)\nRStudio Desktop Pro ‚Äì Paid\n\nFor almost everyone‚Äîstudents, researchers, and individual users‚Äîthe free RStudio Desktop has all the features you need for R programming.\nThe Pro version is essentially the same software but includes two additional benefits intended for organizations:\n\nA Commercial License\nSome companies cannot use software licensed under the AGPL (the license for the free version).\nThe Pro edition provides a commercial license that allows organizations to;\n\nusing RStudio in internal, closed-source, or proprietary environments\navoid releasing modified source code\ncomply with strict corporate software policies\n\nMost individual users, students, and researchers do not need this.\nAccess to Priority Support\nRStudio Desktop Pro includes:\n\ndirect support from Posit engineers\nguaranteed response times\nassistance with installation, errors, and configuration\n\nUsers of the free version still have excellent community resources such as:\n\nPosit Community\nStack Overflow\nGithub issues\nonline forums and tutorials\n\n\nGo ahead and click on \"DOWNLOAD RSTUDIO DESKTOP\" under the Open Source Edition to get the free version of RStudio.\n\n\n\n\n\nThis will take you to the DOWNLOAD RStudio Desktop page\nSelect DOWNLOAD RSTUDIO On the DOWNLOAD RStudio Desktop page select DOWNLOAD RSTUDIO.\n\n\n\n\n\nThis will take you to the RStudio Desktop installers page.\nDownload the appropriate RStudio Desktop installer for your machine.\nOn the RStudio Desktop installers page, you will see a short checklist before the actual installer download links. The first item is \"1: Install \", which is a reminder that  must be installed before RStudio can be used.\n\nIf you have not yet installed , clicking this will take you to CRAN (the official  website), where you can download a precompiled binary of  for your operating system.\nIf you have already installed , you can safely ignore this step and proceed directly to downloading RStudio.\n\nFor Windows users, clicking \"DOWNLOAD RSTUDIO DESKTOP FOR WINDOWS\" will immediately start the download of the installer (.exe file).\n\n\n\n\n\nIf you are using macOS or Linux, simply scroll down the page to find the appropriate installer for your operating system and follow the corresponding instructions.\n\n\n\n\n\nRun the installer.\nOnce the download is complete, locate the installer file and launch it.\n\nOn Windows, double-click the .exe file.\nOn macOS, open the .dmg file and follow the on-screen instructions.\n\nThis will launch the RStudio installation wizard, starting with a welcome screen similar to the one shown below.\n\n\n\n\n\nProceed through the setup wizard by following the prompts. When you reach the ‚ÄúChoose Install Location‚Äù screen, it is strongly recommended to keep the default installation path unless you have a specific reason to change it. Click Install to continue.\n\n\n\n\n\nRStudio will then begin installing the required files on your system.\n\n\n\n\n\nOnce the installation completes successfully, click Finish to exit the installer. RStudio Desktop is now installed and ready to use.\nLaunch RStudio and start working\nOnce installation is complete, launch RStudio Desktop from your applications menu or desktop shortcut. There‚Äôs no need to open the base  application separately‚ÄîRStudio automatically detects and uses the  installation on your system.\nAs RStudio opens, you may briefly see a start-up process similar to the one shown below.\n\n\n\n\n\nOnce RStudio opens, you‚Äôll be greeted by it‚Äôs main interface, as shown below:\n\n\n\n\n\nFrom this point onward, you can work entirely within RStudio. The IDE is now fully connected to , providing a more powerful and user-friendly environment for writing code, running analyses, managing projects, and creating visualizations.\n\nüéâ Congratulations!\nYou‚Äôre now fully set up and ready to start working with  using the RStudio IDE.\n\n\n\n\n\n\nImportantDo I Still Need to Download ?\n\n\n\nYes. Even if you plan to use RStudio, you must install  on your computer.\nRStudio is an Integrated Development Environment (IDE) that makes working with R easier, but it does not include R itself. Instead, it connects to and runs the version of  installed on your system.\n\n\nBefore diving into coding, it‚Äôs worth spending a few moments customizing RStudio to enhance your experience (trust me, it makes a difference).To access the settings via Global Options, follow these steps:\n\nOn macOS, go to Tools ‚Üí Global Options or simply press ‚åò + ,.\nOn Windows, head to Tools ‚Üí Global Options or press Ctrl + ,.\n\n\n\n\n\n\nYou should be greeted with the Global Options window as below.\n\n\n\n\n\nRStudio offers many customization options, and over time you‚Äôll naturally adjust them to match your personal workflow. For now, I‚Äôll highlight just a few essential settings that are especially helpful for beginners and will set you up for a smoother experience from the start.\n\nCode Formatting (Code ‚Üí Editing)\nStart by improving how your code is structured and displayed.\nIn the Code ‚Üí Editing tab, enable at least the first five options, paying special attention to ‚ÄúAuto-indent code after paste.‚Äù\n\n\n\n\n\nThis setting automatically fixes indentation when you paste code, helping your scripts stay clean and readable without extra effort. Good indentation isn‚Äôt just about aesthetics‚Äîit makes your code easier to follow, debug, and maintain, especially as your scripts grow longer or more complex.\nIf you‚Äôre just starting out, these options quietly enforce good coding habits in the background.\nCode Visibility (Code ‚Üí Display)\nNext, make it easier to see where you are in your code.\nIn the Code ‚Üí Display tab, consider enabling the first three options. One especially useful feature is ‚ÄúHighlight selected line.‚Äù\n\n\n\n\n\nThis highlights the line your cursor is currently on, which is incredibly helpful when working in long scripts. It reduces eye strain and helps you avoid running or editing the wrong line by mistake.\nAppearance and Personalization (Appearance)\nFinally, customize how RStudio looks and feels.\nUnder the Appearance section, you can choose an Editor Theme, which controls the color scheme of your code editor. This is one of the most noticeable and impactful changes you can make.\nTake a moment to browse through the available themes and pick one that feels comfortable to you‚Äîthere‚Äôs no ‚Äúcorrect‚Äù choice here. Personally, I recommend trying a dark theme, especially if you code for long periods, as it can reduce eye strain. My go-to choice is Solarized Dark, but feel free to experiment and settle on what works best for your eyes.\n\n\n\n\n\n\nOnce you have selected your preferred options, click ‚ÄúApply‚Äù to save the settings and apply the changes.\nThese small tweaks can make a big difference in your overall RStudio experience, giving you a smoother, more comfortable environment as you embark on your  programming journey.\n\n3.2.2.1 The RStudio Interface\nThe RStudio interface is divided into four quadrants, each serving a specific function:\n\nThe Console window,\nThe Source window,\nThe Environment | History | Connections | Tutorial window, and\nThe Files | Plots | Packages | Help | Viewer window\n\n\n\n\n\n\nWhile you can customize the layout of the panes in the RStudio interface, I personally prefer the default arrangement. To change the pane layout, go to Tools ‚Üí Global Options. Under Global Options, select the Pane Layout option and adjust the panes to your liking.\nYou may notice that sometimes the Source window isn‚Äôt visible when you first open RStudio. This happens when there‚Äôs no file opened. To activate the Source window, either open an existing file or create a new one by selecting File ‚Üí New File ‚Üí R Script from the menu bar, or by using the keyboard shortcut Ctrl + Shift + N on Windows or ‚åò + Shift + N on macOS.\nNow, let‚Äôs briefly explore the purpose of each pane and how they contribute to your workflow in .\n\n3.2.2.1.1 The Console Window\nThe Console is normally located in the bottom-left pane of RStudio unless changed. This is where the  engine you installed separately actually runs inside RStudio. In other words, it is the same R Console you would see if you opened base R on its own, but now embedded within the RStudio interface.\nThe Console displays the output of your commands and computations, and you can also type and execute R code directly here‚Äîjust as you did earlier when working with base R.\nLet‚Äôs try a quick example by calculating the sum of 20 + 7. Click into the Console, type the following, and press Enter/Return ‚Üµ on your keyboard. The result should be straightforward:\n\n# We type this directly into the console:\n20 + 7\n\nHere‚Äôs an example of how it should appear in your RStudio Console:\n\n\n\n\n\nIn the top-right corner of the Console pane, you‚Äôll notice a broom icon. This is an important feature for clearing the Console when it gets too cluttered. If you want to remove all the text in the Console, simply click the broom icon. Alternatively, you can use the handy keyboard shortcut Ctrl + L on both Windows and Mac for the same purpose. If you prefer using code, the following commands can also clear the Console:\n\n# On Windows:\nshell(\"cls\")\n\n# or\ncat(\"\\014\") \n\n# On Linux or macOS:\nshell(\"clear\")\n\n\n\n3.2.2.1.2 The source Window\nLocated in the top-left pane of RStudio, the Source Window serves as a versatile space for managing various types of files, including data, programming code, and notes. The term ‚Äúsource‚Äù encompasses any file you wish to work with. The Source panel can fulfill multiple functions, such as:\n\nInspecting Data: View datasets in a spreadsheet-like (Excel-style) format, making it easier to explore and understand your data.\nWriting and Editing R Scripts: Create, open, and modify R scripts where you write code for your analyses and projects.\nWorking with Other Text-Based Files: The Source window can also open and edit a wide range of file formats, including:\n\nPlain text files (.txt)\nMarkdown files (.md)\nHTML documents (.html)\nLaTeX files (.tex)\nBibTeX files (.bib)\n\nRunning Analyses: Code written in the Source window can be executed line by line or in chunks, allowing you to run analyses, generate outputs, and build results in a structured and reproducible way.\n\n\n\n\n\n\nIn essence, the Source window provides a workspace for any text-based file that RStudio can read. It is where most of your coding and project development will take place, making it one of the most important components of the RStudio interface. However, it‚Äôs important to note that Microsoft Office documents and non-text files (like images) are not supported in this pane. This limitation emphasizes the focus on coding and text editing within the Source window.\n\n\n\n\n\n\nTipWhy use the Source window instead of the Console?\n\n\n\nWhile you can type and run code directly in the Console, the Source window is strongly recommended for most work because it allows you to:\n\nSave your code for future use\nReproduce your analyses exactly at a later time\nOrganize your work into scripts rather than relying on temporary command\nEdit and review code before running it\n\nIn short, the Console is great for quick tests, but the Source window is where real, reusable work happens.\n\n\n\n\n3.2.2.1.3 The Environment | History | Connections | Tutorial Pane\nThe top-right pane in RStudio is a multi-purpose area made up of several tabs, each designed to help you manage and understand your work more effectively.\nThe Environment tab shows all the objects currently available in your R session‚Äîthat is, everything R has in memory and can work with. One of the first and most important objects you will create is a dataset, since data is central to nearly all analyses.\nAs you continue working in , this pane may also contain:\n\nDatasets\nVectors\nLists\nFunctions you define\nOther objects created during your analysis\n\nIf these terms are unfamiliar right now, don‚Äôt worry‚Äîwe will introduce and explain each of them step by step in later sections. For now, it‚Äôs enough to know that the Environment pane acts like a dashboard, allowing you to quickly see what objects exist, inspect them, and manage your workspace.\n\n\n\n\n\nThe History tab keeps a record of the commands you have run during your current and past R sessions. This can be helpful if you want to revisit, reuse, or rerun previous code without typing it again. For example, if you computed the sum of 20 + 7, this entry will be stored in your history. You can quickly insert this command back into the console by clicking on it in the History pane and selecting To Console. This action will paste 20 + 7 back into the console, allowing you to hit Return ‚Üµ to retrieve the result. Alternatively, you can copy the command into an existing or new R Script by clicking on To Source, enabling you to save and reuse it later. If you want to preserve your command history, you can click on the floppy disk icon to save it. Additionally, you can delete individual entries using the button with a white page and red circle, or clear the entire history using the broom icon (note that this action is irreversible).\n\n\n\n\n\nThe Connections tab is used when working with external data sources such as databases or remote storage systems. Beginners may not use this tab immediately, but it becomes useful when working with larger or more complex data sources.\n\n\n\n\n\nLastly, the Tutorial tab provides interactive, guided learning content. Some  packages include tutorials that appear here, making it a convenient space for hands-on learning directly within RStudio.\n\n\n\n\n\n\n\n3.2.2.1.4 The Files | Plots | Packages | Help | Viewer | Presentation Pane\nThe bottom-right pane of RStudio is made up of five important tabs, each designed to support different aspects of your workflow; from managing files to viewing plots and accessing help.\nThe Files tab displays all files and folders within your working directory‚Äîthe default location where RStudio reads from and saves files such as scripts, data, and outputs. This tab acts like a built-in file browser, allowing you to navigate your folders without leaving RStudio.\nUsing the Files pane, you can:\n\nOpen and view files\nNavigate to datasets you want to load into \nCreate, rename, or delete folders\nKeep your work neatly organized\n\nLater in this guide, we will explore R projects and working directories in more detail. For now, it‚Äôs helpful to think of the Files tab as your central navigation hub inside RStudio‚Äîkeeping all the components of your work easy to find and manage in one place.\n\n\n\n\n\nBecause the Console is designed primarily for text input and output, it cannot display visualizations directly. Instead, RStudio offers the Plots tab, which is equivalent to the ‚ÄúR Graphics‚Äù window in base . This tab is specificzlly dedicated to rendering and displaying any graphs or charts you create.\nLet‚Äôs walk through a simple example. Type the following code into your Console to generate a basic boxplot (remember to press Enter/Return ‚Üµ to run the code)\n\n# This creates a basic boxplot using the built-in 'mtcars' dataset\nboxplot(mtcars$hp)\n\nThe mtcars dataset comes pre-installed with R, making it convenient for quick demonstrations. In this example, the boxplot() function is used to visualize the distribution of the hp (horsepower) variable.Once you run the code, the resulting plot will automatically appear in the Plots tab of RStudio.\n\n\n\n\n\nYou can navigate through multiple plots by using the arrow buttons in this pane. To delete the current plot, click on the red circle with a white 'x', or clear all plots by using the broom icon. You can also export your plot for use in presentations or reports, with options for saving it as an image file or PDF.\nThe Packages tab is used to manage additional tools, known as packages, that extend R‚Äôs functionality. You can think of packages as apps for your phone. Each package adds new capabilities, such as creating advanced visualizations, performing machine learning analyses, or simplifying repetitive tasks.\nBy default,  comes with a set of basic packages already installed, but many analyses require additional packages that you can install as needed. The Packages pane displays a list of all packages currently installed on your system. From here, you can load or unload packages and quickly check which tools are available for your work.\n\n\n\n\n\nThe Help tab is your primary go-to reference when you need assistance while working in , and it also provides quick access to official documentation, manuals, learning resources, and other useful reference materials related to  and RStudio..\n\n\n\n\n\nThe Help tab also provides detailed documentation for  functions, datasets, and packages. Whenever you are unsure how a function works, what arguments it accepts, or what a dataset contains, the Help pane is usually the first place you should look.\nFor instance, if you want to explore details about the built-in mtcars dataset used earlier, simply type the following command into the Console:\n\n# Type a '?' followed by the name of a dataset/function/etc.\n# to look up helpful information about it.\n?mtcars\n\nRunning this command opens the Help tab and displays comprehensive information about the dataset, including a description, variable definitions, and usage examples.\n\n\n\n\n\nYou can also use the search bar within the Help pane to look up specific topics or browse related documentation. Beyond RStudio, there is a rich ecosystem of online resources for learning and troubleshooting. For additional learning, I highly recommend CRAN‚Äôs ‚ÄòGetting Help with R‚Äô webpage. And if you‚Äôre ever stuck, don‚Äôt hesitate to expand your search to other resources, such as Google, Stack Overflow or Twitter (using #RStats).\nLastly, the Viewer tab is designed to display dynamic and interactive content that cannot be shown in the static Plots tab. This includes HTML-based outputs such as interactive visualizations, web dashboards (for example, Shiny apps), maps, and even entire websites generated from R. Content shown here is often interactive, allowing you to interact with your results in real-time within RStudio. If needed, these outputs can also be opened in your default web browser for a larger or more flexible viewing experience.\nClosely related is the Presentation tab, which is used when creating slide presentations directly from R using tools such as R Markdown or Quarto. When you render a presentation, the slides are displayed in this pane, allowing you to preview, navigate, and present your work without leaving RStudio. This feature is particularly useful for preparing lectures, project presentations, or research talks that combine code, results, and narrative in one reproducible workflow.\nAlthough this guide focuses mainly on static two-dimensional plots, which are commonly used in assignments, theses, and academic publications, it is useful to know that RStudio is capable of producing and displaying far more advanced and interactive outputs when your projects require them.\n\n\n\n3.2.2.2 Working Directories and Starting your R Projects in RStudio\nOnce you have installed R and begun working with it, one of the first practical challenges you will encounter is file management (importing data or saving output). Questions such as ‚ÄúWhere is my data located?‚Äù or ‚ÄúWhere did R save my output?‚Äù are very common for beginners. This is where the concept of working directories and startup files becomes important.\nIn simple terms, a working directory is a folder on your computer where R looks for files to read and where it saves files by default. When R is first installed, it assigns a default working directory, which is often your home or ‚ÄúDocuments‚Äù folder (for example, C:/Users/YourName/Documents on Windows).\nUnless you explicitly tell R otherwise, any data you load, plots you save, or files you create will be read from or written to this directory. This is why understanding and controlling your working directory is essential for organized and reproducible work.\nWhile working directories control where R reads and writes files, R also uses a small set of startup and session files to control what is loaded, remembered, or configured when a session begins.\nThese files do not replace good project organization, but they strongly influence how R behaves when it starts‚Äîwhat objects appear in memory, what commands are remembered, and what settings or environment variables are applied. Understanding them helps explain why R sometimes behaves differently across sessions or directories, especially for beginners.\n\n3.2.2.2.1  Startup and Session Files\nAs you begin using R, you may notice several files with names that start with a dot (.), such as:\n\n.RData\n.Rhistory\n.Rprofile\n.Renviron\n\nEach of these files can be created manually if needed. In practice, some are generated automatically as you work in R, whereas others are created only when you want to control startup behavior, environment variables, or session settings.\nLet‚Äôs look at each one in turn.\n.RData: Saving and Restoring Your Workspace\nThe .RData file stores a snapshot of your entire R workspace. This includes all objects currently in memory, such as datasets, model objects, functions, and intermediate results. R creates or updates this file only if you choose to save your workspace when exiting R or RStudio. When you restart R in the same directory, it can automatically reload everything from .RData, restoring your previous session.\nWhile convenient, automatically saving and restoring .RData can cause problems in reproducible workflows:\n\nYou may accidentally carry over outdated objects or variables from a previous session.\nScripts that rely on a clean environment may behave inconsistently.\nIt can make debugging more difficult if old objects interfere with your current analysis.\n\nFor these reasons, many experienced users often disable automatic workspace saving. Doing so ensures that each session starts clean, making your analyses more predictable and reproducible.\nHowever, there are valid scenarios where manually saving your workspace as an .RData file is very useful. For example, during computationally intensive workflows, such as training machine learning models with repeated k-fold cross-validation, results can take hours to compute. Re-running the models may also lead to slightly different results due to randomness in resampling or model initialization.\nIn such cases, saving the workspace as an .RData file allows you to:\n\nPreserve trained models, tuning results, and custom functions\nResume analysis without recomputation\nEnsure consistency when preparing tables or figures for reporting\n\nYou can manually save your workspace using:\n\nsave.image(file = \"My_Workspace.RData\")\n\nAnd later reload it with:\n\nload(\"My_Workspace.RData\")\n\n\n\n\n\n\n\nTip\n\n\n\nTo improve reproducibility across projects, it is recommended to adjust RStudio‚Äôs default behavior:\n\nNavigate to Tools ‚Üí Global Options ‚Üí General\nUnder the Basic tab, uncheck the following:\n\nRestore most recently opened project at startup\nRestore previously open source documents at startup\nRestore .RData into workspace at startup\n\nUnder Workspace, set Save workspace to .RData on exit to Never.\n\nStarting each session with a clean workspace minimizes confusion and ensures that projects remain independent and reproducible. These changes aren‚Äôt mandatory‚Äîyou can always adjust them later once you better understand their importance. But implementing them early can save you many headaches as you progress in R.\n\n\n.Rhistory: Tracking Console Commands\nThe .Rhistory file stores the history of all the commands you‚Äôve entered in the R console. It allows you to recall past commands easily, making it a helpful tool for navigating through previous work. You can access your command history using the history() function or by simply scrolling through past commands using the up and down arrow keys while in the Console. Remember, in RStudio we can also access our history in the \"History\" tab under the \"Environment | History | Connections | Tutorial\" Pane.\nThat said, relying solely on .Rhistory is not recommended for serious analysis. Important code should always be saved in scripts rather than relying on command history.\n.Rprofile: Customizing R at Startup\nThe .Rprofile file allows users to customize the behavior of R everytime it starts. It is written in R code and can contain commands that automatically run when an R session begins. For example, you might use it to:\n\nSet a preferred working directory\nDefine custom options (e.g., number formatting, default stringsAsFactors behavior)\nLoad frequently used functions (though beginners are advised to avoid automatically loading packages)\n\n.Rprofile files can exist at two levels:\n\nUser-level: Located in your home directory (e.g., ~/.Rprofile). Settings here apply to all R sessions on your computer.\nProject-level: Stored in a specific project folder. Settings here only apply to R sessions started in that project.\n\nIf both user-level and project-level .Rprofile files exist, R prioritizes the project-level file. You can explicitly include the user-level .Rprofile in a project-level file using:\n\nsource(\"~/.Rprofile\")\n\nYou can create or edit your .Rprofile file conveniently in RStudio using\n\nusethis::edit_r_profile()\n\nThis will open the .Rprofile file in RStudio for editing.\n\n\n\n\n\n\nTip\n\n\n\nTips for Beginners\n\nKeep your .Rprofile minimal at first. Avoid automatically loading packages until you are comfortable with R sessions and reproducibility.\nFocus on small customizations that make your workflow smoother, such as setting options or defining simple helper functions.\n\n\n\n.Renviron: Managing Environment Variables Securely\nThe .Renviron file allows you to define environment variables that are automatically loaded when R starts. Environment variables are useful for storing sensitive information, such as API keys, database credentials, or file paths, without hard-coding them into your scripts. This helps keep your workflows secure and reproducible.\nThe .Renviron file follows a simple key-value format:\nAPI_KEY=abcd1234\nDB_PASSWORD=mysecretpassword\nYou can access these variables during your R session using Sys.getenv()\n\nSys.getenv(\"API_KEY\")\n# [1] \"abcd1234\"\n\nSimilar to the .Rprofile, .Renviron files can also exist at two levels:\n\nUser-level: Located in your home directory (e.g., ~/.Renviron). Variables here are available to all R sessions.\nProject-level: Located in a specific project folder. Variables here only apply when working in that project.\n\nIf both user- and project-level files exist, R prioritizes the project-level file, unless you explicitly source the user-level file.\nTo create or edit your .Renviron file, you can use\n\nusethis::edit_r_environ()\n\nThis opens the .Renviron file in RStudio for editing, allowing you to add, modify, or remove environment variables.\n\n\n\n\n\n\nTip\n\n\n\nTips for Beginners\n\nAvoid storing sensitive credentials directly in scripts. Use .Renviron instead.\nKeep your environment variables organized and documented so you and collaborators can understand them later.\nRemember to restart your R session after editing .Renviron to load changes.\n\n\n\n\nSummary Table: Common .R* Files in R\n\n\n\n\n\n\n\n\nFile\nPurpose\nScope\nExample Use\n\n\n\n\n.Rprofile\nRun R code automatically at startup\nUser or project\nSet global options, define helper functions, configure project-specific behavior\n\n\n.Rhistory\nStore console command history\nPer directory/session\nRecall and reuse previously run commands\n\n\n.Renviron\nStore environment variables securely\nUser or project\nAPI keys, authentication tokens, library paths\n\n\n.RData\nSave and restore the entire R workspace\nPer directory\nPreserve trained models, analysis objects, or long-running results\n\n\n\nUnderstanding these files early in your R journey helps you avoid confusion and develop good programming habits. Not every project will require all of them, and many beginners can work comfortably for a long time without touching most of these files.\nHowever, knowing what each file does, when it is created, and how it affects your R sessions gives you greater control over your workflow. More importantly, it prepares you to understand why tools like RStudio Projects exist and how they solve many of the problems caused by unmanaged working directories and hidden session state.\n\n\n3.2.2.2.2 How Working Directories Fit Into the Bigger Picture\nNow that we understand how R manages startup behavior and session state, we return to a concept that beginners interact with constantly‚Äîthe working directory. Unlike startup files, which affect how R starts, the working directory determines where R reads data from and where it writes output during your analysis as previously described.\nIn RStudio, the current working directory is shown at the top of the Console pane, making it easy to confirm at a glance. You can also check your current working directory by running the command getwd() in the console.\n\ngetwd()\n\nThis command prints the full file path of the directory R is currently using.\nIf you‚Äôre not using RStudio Projects, you must manually set the working directory at the start of every R script using the setwd() function:\n\nsetwd(\"C:/Users/Elias Nelson Kaunda/Documents/Intro-to-R\")\n\nThis tells R to use the ‚ÄúIntro-to-R‚Äù folder as it‚Äôs working directory. From that point onward, any files you load or save will be read from or written to this folder by default.\nFor example, when you load a dataset using read.csv(\"data.csv\"), R will look for data.csv inside the \"Intro-to-R\" directory.\nHowever, there‚Äôs a catch; setwd() uses an absolute file path, which is specific to your computer‚Äôs directory structure. If you share your script with someone else or switch to a different computer, the path will fail unless their directory structure matches yours exactly. In practice, this almost never happens (you are unlikely to have a directory structure like mine: \"C:/Users/Elias Nelson Kaunda/Documents/Intro-to-R\" on your computer).\nThis creates problems for:\n\nCollaboration\nLong-term projects\nReproducibility\nMoving between computers\n\nBecause of this, relying on setwd() is generally discouraged for serious or shared work.\nRStudio provides a solution to this problem through R Projects (files with the .Rproj extension). Using RStudio projects eliminates so much of the early-stage hassle and confusion around reading in and exporting data. When you open an R Project, RStudio automatically sets the working directory to the folder containing the project file. This removes the need to manually set the working directory and allows you to use relative paths throughout your analysis.\nRelative paths are paths that start from the project root rather than from your computers file system. This makes scripts portable, reproducible, and easy to share while collaborating with others.\nFor example, if you need to share your analysis with a colleague, you can send the entire project folder. Once your colleague opens the .Rproj file in RStudio, all scripts that rely on relative paths will work as expected, without needing to manually set or modify the working directory.\nUsing R Projects offers several key benefits:\n\nFile Organization: All files related to a project‚Äîdata, scripts, figures, and reports‚Äîlive in one dedicated folder. This keeps your work tidy and easier to understand.\nReproducibility: Relative paths ensure that analyses run the same way on different computers without modifying file paths.\nCollaboration: You can share the entire project folder with a colleague, who can open the .Rproj file and run your scripts immediately.\nVersion Control: R Projects integrate seamlessly with Git and GitHub, allowing you to use version control to track changes to your code over time. This is especially useful for collaboration or when you need to roll back to a previous version of your analysis.\nConvenience: RStudio automatically manages the working directory for you, reducing setup errors and mental overhead.\n\n\n\n3.2.2.2.3 Creating a New R Project in RStudio\nHere‚Äôs how you can create a new R Project in RStudio:\n\nNavigate to File ‚Üí New Project from the menu bar\n\n\n\n\n\n\nor use the project dropdown in the top-right corner and select New Project.\n\n\n\n\n\n\nIn the dialog box, choose New Directory.\n\n\n\n\n\n\n\nNext, select New Project.\n\n\n\n\n\n\n\nEnter a clear, descriptive name for your project folder (referred to as the Directory Name) that reflects the nature of your work. Make sure to save this project folder in a logical and organized location on your computer. You can adjust the folder‚Äôs location by clicking Browse‚Ä¶ and selecting the appropriate directory. Ideally, this should be a folder where you routinely store your research or analysis projects, ensuring easy access and consistency in file management.\n\n\n\n\n\n\n\nOptionally, you can create a Git repository for version control by ticking the Create a git repository checkbox. If you‚Äôre unfamiliar with Git or don‚Äôt use GitHub, you can safely ignore this option for now.\nCheck the Open in new session option to open your new project in a fresh RStudio window.\nOnce you‚Äôre satisfied with the settings, click Create Project. RStudio will open a new session for your project, and you‚Äôre ready to begin.\n\n\n\n\n\n\nOnce your project is set up, you‚Äôll notice a few changes in RStudio:\n\nThe project name will appear at the top of the RStudio window.\nThe Files pane will show the root directory (i.e., your project folder), making it easy to navigate through your project files.\nThe Console will display the current file path of your project.\n\nThis setup ensures that all your scripts, data, and output are stored together in one place. While you could configure all this manually using setwd(), R Projects make the process much more intuitive and efficient.\n\n\n\n3.2.2.3 Organizing Your  Projects and Structuring Your Working Directories\nThis section is not about the technical aspects of RStudio, R, or data analysis per se. Instead, it‚Äôs about the often overlooked yet crucial habit of organizing your work through a solid folder structure. Like good coding practices, setting up a clear, logical folder structure can significantly boost your productivity and reduce frustration. A well-structured project directory will help you quickly locate files, avoid clutter, and make your work easier to share or revisit later. This is especially important when working with R projects in RStudio.\nBefore you start coding, take some time to plan your folder structure. Having dedicated folders for different file types, rather than dumping everything into one container, will save you time and prevent headaches down the line. Whether you create your folder structure within RStudio or through your file browser, the key is to be organized.\nGood folder organization also plays a critical role in reproducible research and analysis. Proper directory setup is one of the ‚Äúnon-code‚Äù aspects of R programming that significantly enhances your workflow, and for beginners, it should be a priority. Structuring your directories in a way that‚Äôs easy to navigate ensures that collaborators‚Äîor your future self‚Äîcan follow and reproduce your work effortlessly.\nA Basic Folder Structure:\nAside from using RStudio projects, it‚Äôs also good practice to set up a working directory that makes your project easy to navigate. Here‚Äôs a basic template you can use as a starting point:\n\n\n\n\n\nFor each project I work on, I usually have at least the following folder structure:\n\nData: This folder contains all the files you‚Äôll need to import into R for analysis or visualization. These could include CSV, Excel, SPSS (*.sav), .FST, .RDS, .tif, .shp, or .gpkg files, depending on your work. It‚Äôs a good idea to create two separate subfolders: one for raw data (untouched, as collected or downloaded) and another for processed or cleaned data (after some wrangling and transformation in R). This ensures that you keep your original data intact while also organizing the processed data outputs.\nR Scripts: Here, you save all your R scripts. This includes your analysis code as well as any custom functions you may write. You might consider creating a subfolder specifically for your functions if you find it convenient to keep them separate. Saving your scripts and functions this way allows for easy re-use across different analyses and projects. Rather than creating separate projects for every analysis, you can store multiple scripts in one project folder‚Äîmaking it easier to manage different tasks on the same dataset.\nOutput: Use this folder to store all the outputs generated from your scripts, such as plots, reports (e.g., HTML or PDF), and any data exports. This folder helps differentiate between input data and the final results, ensuring others (or you, in the future) can easily identify the outputs of your analysis.\n\nIn RStudio, your directory structure might look like this:\n\n\n\n\n\nThis template should serve as a good starting point if you‚Äôre new to project organization. However, remember that each project has its unique requirements. You should always adapt the directory structure to fit the specific needs of the project while maintaining a level of consistency that simplifies collaboration and future work.\n\n\n\n\n\n\nNote\n\n\n\nIt‚Äôs also a good practice to use lowercase for folder names, as shown in the example above. This makes it easier when you reference folder names in your code for reading or writing files, reducing potential errors related to case sensitivity.\n\n\nBy adopting this structure early on, you‚Äôll streamline your workflow, improve the reproducibility of your work, and make it easier to share or revisit your projects with confidence.\n\n\n3.2.2.4 Writing  Scripts in RStudio\nCode quickly becomes long and complex. Thus, it is not very convenient to write it in the console. So, instead, we can write code into an R Script. Remember the ‚ÄúR Editor‚Äù window we encountered in the base RGUI‚Äîwell the R Script in RStudio could be considered as it‚Äôs equivalent, but much better. An R Script is a document that RStudio recognizes as R programming code. Files that are not R Scripts, like .txt, .rtf or .md, can also be opened in RStudio, but any code written in it will not be automatically recognized.\nWhen opening an R script or creating a new one, it will display in the ‚ÄúSource‚Äú window. Some refer to this window as the ‚Äòscript editor‚Äô. An R script starts as an empty file. Good coding etiquette, demands that we use the first line to indicate what this file does by using a comment ‚Äò#‚Äô.\nPerhaps one of the most important aspects of making your code comprehensible for others and your future self is adding comments about why you did something. You can write comments directly in your script, and tell R not no execute those words simply by putting a hashtag (#) before you start typing the comment.\nComments can be used to explain R code, and to make it more readable. It can also be used to prevent execution when testing alternative code.\nComments starts with a #. When executing code, R will ignore anything that starts with #.üî•\nBelow are examples of how you can use comments in R‚Äôs syntax:\n\n# Load dplyr package\n1library(dplyr)\n\nmtcars_summary &lt;- mtcars %&gt;%\n  filter(cyl == 6) %&gt;% \n  select(mpg, hp, wt) %&gt;%\n  summarise(\n2    avg_mpg = mean(mpg),\n    avg_hp = mean(hp),\n    avg_wt = mean(wt)\n  )\n\n\n1\n\ndplyr is one of the cornerstone of the tidyverse, really useful for data wrangling.\n\n2\n\nhere I‚Äôm computing 3 variables, the averages of mpg, hp and wt\n\n\n\n\n\n\n\nHover over the circled numbers for additional context.\n\nHere is an example.\n\n# Create a boxplot to visualize miles per gallon (mpg) by the number of cylinders (cyl)\n\n# Load the built-in 'mtcars' dataset\n# This dataset provides information on various car models and their specifications\nhead(mtcars)  # Display the first few rows to understand the structure of the dataset\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n# Create a boxplot using base R functions\n# Group the 'mpg' variable by the 'cyl' variable (number of cylinders)\nboxplot(mpg ~ cyl,            # Formula notation indicating mpg by cyl\n        data = mtcars,       # Specify the dataset\n        main = \"Miles per Gallon by Number of Cylinders\",  # Title of the plot\n        xlab = \"Number of Cylinders\",  # Label for the x-axis\n        ylab = \"Miles per Gallon\",     # Label for the y-axis\n        col = c(\"#FF5733\", \"#6A0DAD\", \"#3BB143\"),  # Colors for each box\n        border = \"grey20\")  # Border color of the boxes\n\n\n\n\n\n\n\n# Comments like these help explain what each part of the code does and why it is used.\n# Always include comments in your R scripts for better readability and understanding.\n\nAll examples in this post can easily be copied and pasted into your own R script. Let‚Äôs try it with the following code. The plot this code creates reveals which car manufacturer produces the most efficient cars. Copy and paste this code into your R script.\n\n\n3.2.2.5 Updating  and RStudio: Staying on the Cutting Edge\nWhile regularly updating your software might not directly improve your programming skills, it can certainly save you from unnecessary frustration down the road. It‚Äôs important to remember that R and RStudio are separate programs, meaning you need to update them individually. Although they work closely together, updating RStudio won‚Äôt automatically update R itself, and vice versa.\nThis distinction becomes crucial when certain tools or packages you‚Äôve installed through RStudio require the latest version of R. For instance, if you‚Äôre using a cutting-edge machine learning algorithm that‚Äôs incompatible with older versions of R, you might run into errors or performance issues. Likewise, R packages developed by the community (which we‚Äôll explore later) also need to be updated independently‚Äîthey are not automatically refreshed when you update R or RStudio.\nNow, I know this sounds a bit tedious, but don‚Äôt worry‚Äîit‚Äôs simpler than it seems. Updating packages within RStudio is straightforward, and I‚Äôll guide you through it. Just keep in mind: R, RStudio, and your packages all need to be updated separately.\nBy staying on top of updates, you‚Äôll ensure that your coding environment remains compatible, efficient, and equipped with the latest features, sparing you the hassle of unexpected errors or incompatibility down the line.\n\n\n\n3.2.3  Visual Studio Code: A General-Purpose IDE and Code Editor for Software Developers and Programming\nRStudio is often the first choice for running  code, largely because it was designed specifically for the  ecosystem and provides a very smooth out-of-the-box experience. However, Visual Studio Code, commonly referred to as VS Code has quickly gained traction as a versatile code editor among software developers working across many programming languages.\nSpeaking from personal experience‚Äîand perhaps echoing the sentiment of others in the  and broader programming communities‚Äîusing  in VS Code often starts as an experiment to find an all-in-one code editor. The motivation is simple: the desire to work within a single editor for all programming tasks. If you already use VS Code for Python, HTML, CSS, JavaScript, or other languages, it feels natural to ask whether  can also fit into that same workflow.\nVS Code is particularly well suited for projects that involve multiple technologies. For example, data analysis in R combined with Python scripts, documentation written in Markdown, and web components written in HTML or JavaScript can all live comfortably in one place. This reduces the constant switching between tools and helps maintain focus when working on complex projects.\nThat said, VS Code is not an -specific IDE. It is a general-purpose source code editor with a very large extension ecosystem. This flexibility is one of its greatest strengths, but it also means that a smooth  experience requires some initial setup.\nVisual Studio Code supports the  programming language through extensions. The most important of these is the  extension for Visual Studio Code, which connects VS Code to your existing  installation.\nOnce properly configured, VS Code can provide many features  users expect, including:\n\nSyntax highlighting for  scripts\nCode completion and function suggestions\nInline diagnostics and error messages\nCode linting and formatting\nInteraction with an  terminal\nViewing data frames, plots, workspace variables, help pages and more\n\nWhile these features may feel familiar to RStudio users, it is important to note that in VS Code they are powered by a combination of extensions and  packages working together.\n\n\nKey idea:\n\nRStudio ships with -specific tools built in.\nVS Code adds  features through extensions and packages.\n\nSetting up VS Code for  isn‚Äôt as straightforward as installing RStudio. This is not a limitation, but rather a design choice. VS Code is designed to support dozens of programming languages. If it shipped with full support for all of them by default, it would be overly complex and resource-heavy. Instead, VS Code uses a modular approach where users install only the extensions they need.\nRStudio, on the other hand, is iconically tailored for . Its tight integration means that many features work immediately after installation without any additional configuration.\nThe flexibility of VS Code is powerful, especially for developers working across multiple languages, but it does mean that configuring VS Code for  requires a few extra steps.\nTo run  in VS Code, as with RStudio, you must already have installed  on your machine.\n\n version 3.4.0 or later is required\nInstalling  using a precompiled binary is recommended for most users\nBuilding  from source is possible but not necessary for beginners\n\nSince we have already covered how to install  on Windows and macOS earlier in this guide, we will skip those steps here and focus instead on configuring VS Code to work with .\n\n3.2.3.1 Setting Up  Packages for VS Code Integration\nTo ensure a smooth experience using  in VS Code, a few essential  packages must be installed before setting up the editor itself.\n\nAn important question would be ‚ÄúWhat Are  Packages‚Äù\n\nIf this is your first encounter with  packages, do not worry. We will explore them in much more detail later in this guide. For now, a simple analogy helps.\nThink of  as a new smartphone. When you first buy it, it comes with basic apps and settings that allow it to function. Over time, you may want to extend its capabilities by installing additional apps from the Google Play Store or Apple App Store.\n packages work in much the same way.  packages are add-ons that give you extra tools‚Äîwhether you‚Äôre cleaning data, creating charts, or building statistical models. Base  comes with many built-in functions and packages that handle common tasks. However, as your work becomes more specialized, you will need additional tools.  packages provide these tools in the form of reusable functions, datasets, and documentation.\nEach package is a small, self-contained toolkit. The more packages you install, the broader the range of tasks you can perform. Packages are also a cornerstone of reproducible research, since they allow others to run the same code using the same tools.\nMost  packages are distributed through the Comprehensive  Archive Network (CRAN), the official public repository for  packages. Although packages can also be installed from local files or other online sources, you do not need to manually visit the CRAN website to download them. Instead, packages can be installed directly from the  console using the install.packages() function.\nNot every  package is hosted on CRAN. Some are available from alternative platforms such as GitHub or Bioconductor, which provide additional or specialized tools.\nTo enable  support in VS Code, you will need to install at least one compulsory  package from CRAN. The key package required fr integration is languageserver.\nOpen  and run the following command in the Console:\n\n# Language Server support\ninstall.packages(\"languageserver\") \n\n\n\n\nFor VS Code, languageserver is required. Everything else is optional (simply recommended).\n\nThis languageserver package allows VS Code to understand your  code. It provides important development features such as code completion, inline diagnostics, function documentation, and object inspection.\nWhile not strictly required, you may also choose to install a few more optional packages that improve the overall  programming experience in VS Code. These packages are not required for  to function in VS Code, but they provide useful quality-of-life features when using  in VS Code.\nTwo commonly recommended optional packages are lintr and httpgd. Just as languageserver, the lintr packae is also available on CRAN and can be installed with the following command:\n\n# Code linting support\ninstall.packages(\"lintr\")\n\nThe lintr package checks your  code for potential issues related to style inconsistencies, potential syntax problems, and violations of recommended best practices. When integrated with VS Code, these checks appear as you type, helping you build good coding habits early on.\n\n\n\nlintr is optional.  will work normally in VS Code without it.\n\n\n  \n\nWhen you run install.packages() for the first time,  may ask you to select a CRAN mirror.\n\n\n\n\n\nCRAN, short for the Comprehensive R Archive Network, is a global network of servers that store  packages. A CRAN mirror is simply a geographically hosted copy of this repository in different locations around the world.\n\n\n\nA CRAN mirror is simply a copy of the same packages hosted in different countries.\n\nYou can safely choose any mirror. If you prefer, you may manually select a mirror located in a country close to you, which can sometimes improve download speed.\nIf you are unsure, selecting 0-Cloud [https] at https://cloud.r-project.org/ is usually the best option. This is not a single server, but a content delivery network that automatically connects you to a nearby server and is generally the best default.\nMost importantly, all CRAN mirrors contain the same packages. The choice only affects download speed, not package content.\nMany  packages rely on other packages to function properly. These supporting packages are called dependencies.\nWhen installing a package,  automatically installs any required dependencies. Seeing multiple packages install at once is normal and expected, so do not be alarmed if you see several additional packages being installed.\nAfter selecting a CRAN mirror, during the installation process, you may see the prompt:\n\n‚ÄúDo you want to install from sources the packages which need compilation?‚Äù\n\n\n\n\n\n\nThis question relates to the two ways  packages are distributed and can be confusing for beginners, so let us break it down.\n packages are distributed in two main forms:\nBinary packages (recommended for beginners)\n\nAlready compiled for your operating system\ninstall quickly\nDo not require additional tools\n\nSource packages\n\nContain original source code\nMust be compiled on your computer\nRequire developer tools (compilers):\n\nWindows: Rtools\nmacOS: Xcode Command Line Tools\nLinux: system build tools\n\n\nWhen  asks whether you want to install from source, it is essentially asking whether you want to compile the package yourself or use a ready-made version.\nFor beginners, the recommended answer is usually NO, because:\n\nBinary packages are easier to install\nNo additional developer tools/software is required\nThere is a lower chance of installation errors\n\nWhen you select NO,  installs pre-compiled binary versions automatically and skips source compilation.\nChoosing Yes only makes sense if:\n\nYou understand what package compilation is\nYou already have the required tools installed (e.g., Rtools)\nYou are following advanced documentation that explicitly tells you to install from source.\n\nFor most beginners, this is not necessary.\nOn Windows and macOS,  usually just installs pre-compiled binary packages automatically, so unless tools like Rtools or Xcode are installed, this prompt may not appear at all. Do not be concerned if you never see it.\n\n\n\nBeginner rule of thumb üß† If unsure, always choose NO when asked about source installation.\n\nOnce you click NO,  will start installing the packages until you should see a message indicating that the downloaded binary packages have been installed successfully.\n\n\n\n\n\nAnother useful optional package is httpgd, which provides a modern interactive graphics device that works well inside editors like VS Code.\nNormally, installation from CRAN would be:\n\n# Install httpgd:\ninstall.packages(\"httpgd\")\n\n\n\n\nhttpgd is an asynchronous HTTP server graphics device for  that enables live graphics to be viewed inside web browsers and IDEs\n\nIf this command succeeds, no further action is required.\nHowever, installation may sometimes fail with a warning similar to the one shown below:\n\n\n\n\n\nWhen a package installation fails, it usually indicates one of the following:\n\nThe package is temporarily unavailable as a binary on the main CRAN repository.\nThe package has been archived on CRAN.\nYour system must compile the package from source\n\nArchived packages remain available in CRAN‚Äôs archive directory, but they are no longer installed through the standard install.packages() workflow.\nCommon reasons a package becomes archived include:\n\nThe package is no longer maintained by its author.\nIt fails CRAN quality checks on newer  versions or operating systems.\nLicensing or CRAN policy issues arise.\nThe maintainer has orphaned the package (stopped maintaining it).\n\nIn addition, archived packages may depend on older versions of {{fa brands r-project}} or other packages, which can make installation more complex.\nThis particular situation introduces the need for build tools\nWhy Build Tools Become Necessary Many  packages often contain compiled code written in C, C++, or FORTRAN. To install such packages from source, your operating system must provide a compiler toolchain, commonly referred to as build tools.\nüñ•Ô∏è Windows: Installing Rtools\nWindows users need to install Rtools following the steps as below:\n\nFirstly check your  version.\n\nIn , run:\n\nR.version.string\n\nThis returns a version string such as:\n\"R version 4.5.2 (2025-10-31)\"\nMake note of the version.\n\nDownload the matching Rtools version\n\nVisit the CRAN Rtools page: https://cran.r-project.org/bin/windows/Rtools/\nChoose the installer that corresponds to your installed  version.\n\n\n\n\n\nUnder installing Rtools4x, click the Rtools4x installer link to begin downloading the installer.\n\n\n\n\n\n\nRun the installer\n\nAccept defaults unless you need a custom installation path.\n\n\n\n\n\nKeep all the Additional Tasks options selected. The default configuration is recommended and requires no changes for a standard Rtools installation.\n\n\n\n\n\nClick install.\n\n\n\n\n\nThe installation process will proceed as below:\n\n\n\n\n\n\nVerify installation\n\nOpen/restart  and run.\n\nsystem(\"make --version\")\n\nIf you see Make version info, Rtools is correctly installed.\n\n\nüçé macOS: Installing Xcode Command Line Tools\n\nOpen Terminal\n\nPress Cmd/‚åò + Space, type Terminal, and hit Enter‚Üµ.\n\nInstall the tools\n\nTo install the tools Run:\nxcode-select --install\n\n\n\n\nConfirm installation\n\nAfter installation, verify with:\ngcc --version\nIf you see version info, the tools are installed.\n\n\nüêß Linux: Installing Development Tools\n\nUpdate your package manager\n\nUbuntu or Debian:\nsudo apt-get update\nFedora or RedHat:\nsudo dnf update\n\n\n\n\nInstall build tools\n\nUbuntu/Debian:\nsudo apt-get install build-essential r-base-dev\nFedora/RedHat:\nsudo dnf groupinstall \"Development Tools\"\n\nsudo dnf install R-devel\n\n\n\n\nVerify installation\n\nVerify installation using:\ngcc --version\n\n\nIf you see version info, the compiler is ready.\nOnce the build tools are successfully installed, you can proceed with installing httpgd, which enables an interactive graphics device for R in VS Code.\nBegin by installing the remotes package, which allows installation of packages directly from GitHub:\n\ninstall.packages(\"remotes\")\n\nBefore installing httpgd, it is recommended to pre-install unigd, a required dependency of:\n\n# Install unigd from GitHub\nremotes::install_github(\"nx10/unigd\")\n\nYou can then install httpgd from GitHub:\n\n# Install httpgd from GitHub\nremotes::install_github(\"nx10/httpgd\")\n\nCompilation may take a few moments. A successful installation will with the message DONE (httpgd) in the comsole.\nTogether, these packages provide a solid and beginner-friendly foundation for working with  in VS Code.\nIn the next section, we will shift focus to Visual Studio Code itself, where we will install the necessary VS Code extensions and configure the editor for everyday  development.\n\n\n3.2.3.2 Installing and integrating  VS Code with \nThe first step in using  inside Visual Studio Code is installing the editor itself. VS Code is free, lightweight, and available for all major operating systems.\n\nStep 1: Download Visual Studio Code\nBegin by downloading Visual Studio Code from the official website: üëâ https://code.visualstudio.com/Download\nChoose the installer that matches your operating system (Windows, Mac or Linux).\n\n\n\n\n\nStep 2: Start the Installation\nVS Code intsalls like any other desktop application.\n\nOn Windows, double-click the downloaded .exe file to start the installer.\nOn macOS, open the downloaded archive and drag VS Code into your Applications folder.\nOn Linux, follow the instructions provided for your distribution.\n\nStep 3: Accept the License Agreement\nRead through the license agreement, accept the terms, and click Next to continue.\n\n\n\n\n\nStep 4: Choose the Installation Location\nUnless you have a specific reason to install VS Code elsewhere, it is best to keep the default installation location.\nClick Next to continue.\n\n\n\n\n\nStep 5: Start Menu Folder\nThe default Start Menu Folder works well for most users. Leave this unchanged and click Next.\n\n\n\n\n\nStep 6: Select Additional Tasks (Recommended Settings)\nThis step is easy to rush through, but it is worth paying attention here.\n\n\n\n\n\nHere is what these options do and why they are useful:\n\nCreate a desktop icon:\nOptional. This simply places a VS Code shortcut on your desktop for quick access.\nAdd ‚ÄúOpen with Code‚Äù to file context menu:\nThis allows you to right-click a file in Windows Explorer and open it directly in VS Code. Very convenient when working with R scripts, Quarto files, or project folders.\nAdd ‚ÄúOpen with Code‚Äù to directory context menu:\nThis lets you right-click an entire folder and open it as a workspace in VS Code. This is especially useful for R projects, as VS Code will treat the folder as a single working environment.\n\nFor beginners, it is safe and recommended to check all three options. They do not change how VS Code behaves internally; they simply make it easier to open files and projects.\nAfter selecting your preferred options, click Next.\nStep 7: Install VS Code\nClick Install to begin the installation process.\n\n\n\n\n\nYou will see a progress screen while VS Code is being installed.\n\n\n\n\n\nStep 8: Finish and Launch\nOnce installation is complete, click Finish.\n\n\n\n\n\nVS Code should launch automatically.\nStep 9: First Launch\nWhen VS Code opens for the first time, you will see a welcome screen. This includes links to tutorials and options to customize the editor‚Äôs appearance.\nFor now, you can leave everything as-is and simply close the welcome tab.\n\n\n\n\n\nAt this point, Visual Studio Code is successfully installed on your system. Next, we will install the  extension extension for VS Code, which allows the editor to understand and run  code.\n\nThis extension adds -specific features such as:\n\nSyntax highlighting\nCode execution\nAn -aware terminal\nBasic editor support for  scripts\n\n\nOpen the Extensions view:\nInside VS Code, look to the Activity Bar on the left-hand side. You will see icons for:\n\nExplorer\nSearch\nSource Control\nRun and Debug\nExtensions.\n\nClick on Extensions (the four-squares icon), or use the keyboard shortcut:\n\nWindows/Linux: Ctrl + Shift + X\nmacOS: ‚åò + Shift + X\n\n\n\n\n\n\nInstall the  extension:\nIn the extensionss search bar type REditorSupport.r.\n\nSelect the extension\nClick install\n\nOnce installed, VS Code now understands  code.\n\n\n\n\n\nConfirm the extension is active\nAfter installation, you should notice a new  icon appear in the Activity Bar, usally just below the Extensions icon. This confirms that the  is active and ready to use\n\n\n\n\n\n\n\n\n3.2.3.3 Making  discoverable by  VS Code: Adding  to PATH\nFor VS Code (and your system terminal) to run , it needs to know where the  executable lives. This is handled through a system setting called PATH.\n\nThink of PATH as a list of folders your computer searches when you type a command like  into a terminal.\n\nOn Windows\n\nLocate your  installation\nBy default,  is installed in a folder similar to:\nC:\\Program Files\\R\\R-x.x.x\\bin\nCopy the path\nOpen File Explorer, navigate to the bin folder inside your  installation. Right-click the folder and select Copy as path. Alternatively you can use the keyboard shortcut Ctrl/‚åò + Shift + C\nOpen Environment Variables.\nPress  Windows key + R, type sysdm.cpl and hit Enter‚Üµ. Go to Advanced tab and click Environment Variables.\n\nEdit the PATH variable.\nUnder System variables, select Path, click Edit ‚Üí New, paste the path you copied (C:\\Program Files\\R\\R-x.x.x\\bin). Click OK to save.\n\n\n\n\n\nOnce this is done, typing  in a terminal should work anywhere on your system.\nTo show a quick demonstration of what this means. Open Command Prompt to run R in the terminal you can simply run:\nR\nOr if you would prefer the vanilla  console run:\nR --vanilla\n\n\nThe vanilla  console refers to a basic  session that does not load any custom settings ( startup file configurations e.g., .Rprofile) or libraries.\nRunning this command opens  in terminal and you can run  code in the terminal.\n\n\n\n\n\n\n\n3.2.3.4 Pointing VS Code directly to  (Rpath setting)\nSometimes the  extension needs an explicit pointer to the  executable.\nTo set this:\n\nGo to File ‚Üí Preferences ‚Üí Settings\nSearch for Rpath\nSet the value to the full path of your  executable:\n\nWindows:\nC:\\Program Files\\R\\R-x.x.x\\bin\\R.exe\nmacOS/Linux:\n/usr/local/bin/R\n\n\n\n\n\n\nThis removes any ambiguity and ensures VS Code always uses the correct  installation.\n\n\n\n3.2.3.5 Starting an  session inside  VS Code\n\nOpen a terminal:\n\n\nMenu: Terminal ‚Üí New Terminal.\nShortcut:\n\nWindows/Linux: Ctrl + `\nmacOS: ‚åò + `\n\n\n\n\n\n\n\n\nClick the dropdown arrow next to the + button in the and select Command Prompt.\n\n\n\n\n\nIn the terminal type:\nR\nand press Enter‚Üµ to start an  session.\n\nAlternatively, from the same dropdown menu next to the + button, select R Terminal. This launches an  session automatically and is often the easiest option for beginners.\n\n\n\n\n\nHere you can run code as we did before in the base  Console or in RStudio‚Äôs Console pane. You can simply run a simple print(\"Hello, World\") program as we did previously. Go ahead and also try a simple arithmetic computation after that.\n\nUp to this point, everything we‚Äôve done has been purely about .\nNow we introduce radian, an enhanced  console that provides:\n\nSyntax highlighting\nBetter auto-completion\nA smoother interactive experience inside VS Code\n\nRadian is an alternative console for . To integrate radian with VS Code, we need to have  and  python installed on our system.\nI get it, right now you‚Äôre wondering how python has made it into our discussion, but take heart and don‚Äôt be too overwhelmed.\nHere‚Äôs the key point:\n\nRadian is written in Python.\nThat‚Äôs why Python is required ‚Äî not because you need to learn Python, but because it acts as a supporting tool for a better  experience.\n\nSo think of Python here as infrastructure, not a new language you must master.\nHowever a very short introduction to Python may be imminent as we need to install the program for us to continue and integrate radian with VS Code. Python is a high-level, general-purpose programming language created by Guido van Rossum and first released in 1991. It is widely known for its readable syntax and is commonly used as a foundation for tools, automation, and scientific software.\nIn our case:\n\nPython is required to install radian\nWe only need Python and pip (Python‚Äôs package manager)\nNo Python programming knowledge is required\n\nYou can safely continue thinking ‚Äúin  throughout this section.\nBefore installing Python you should first check if python isn‚Äôt already installed on your computer:\nOn Windows, to open Command Prompt\n\nPress  Windows key + R\nType cmd in the Run Dialog Box\nPress Enter‚Üµ or click OK\nIn the Command Prompt terminal, type:\npython --version\nthen press Enter‚Üµ.\n\nIf Python is installed, you‚Äôll see a version number e.g., Python 3.12.7.\nIf not, Windows will report that Python is not recognized.\n\n\n\n\nTip: Use your mouse to copy and paste commands ‚Äî standard Ctrl/‚åò + C and Ctrl/‚åò+ V keyboard shortcuts may not work in some terminals.\n\n\n\n\n\nOn macOS\n\nPress ‚åò + Space\nSearch for Terminal and press Enter‚Üµ.\nRun the same command:\npython --version\n\nIf Python is not installed follow the steps below to install it:\n\nVisit www.python.org\nClick Download\n\n\n\n\n\nChoose the installer for your operating system\n\n\n\n\n\nFor Windows users click the Windows link and then click on the Download Windows installer (xx-bit) for your appropriate bit type under the Stable Releases under Stable Releases\n\n\n\n\n\nFor other users (macOS or Linux) follow the links provided to download python.\nInstall Python\nFor Windows users simply double-click the .exe installer to begin the installation process.\n\n\n\n\n\nBefore clicking Install Now, check the following options:\n\n‚òëÔ∏é Use admin privileges when installing py.exe\n\nEnsures that the installation proceeds without restrictions as the installation process requires elevated permissions to modify system files and settings,\n\n‚òë Add python.exe to PATH\n\nThis is important because you‚Äôre tellig your operating system where to find python (or python3). This allows you to run Python from the terminal by typing python. Remember we earlier had to do this manually for , well this affords to avoid the gruesome some of having to do that manually for Python.\n\n\n\n\n\n\n\nNoteNote on multiple  Python versions:\n\n\n\nIf you already have another Python version installed, PATH order matters. In such cases, tools may use the first Python version found. Advanced users often use version managers, but beginners can safely proceed with the default setup and explicitly call the version you want e.g., python3.11 or python3.12 when the need arises\n\n\n\nClick Install Now and let the installation complete.\n\n\n\n\n\nClick close once the installation is successful as below.\n\n\n\n\n\n\nYou are now fully prepared to install and configure radian, giving you a powerful and pleasant interactive  console inside VS Code ‚Äî without needing to learn Python itself.\nFinally to install radian :\n\nOpen the Command Prompt terminal while in VS Code as we did before.\nFirstly make sure you are using an updated version pip. the safest is to upgrade pip, setuptools and wheel. Outdated packaging tools often can cause errors. In your opened command prompt terminal run:\npython -m pip install --upgrade pip setuptools wheel\nAfter making sure you have updated packing tools, run the following command to install radian:\npip install radian\nThe installation process should take a whille but a successful installation of radian will look like:\nTo further confirm radians installation run the command below in the same terminal:\nradian --version\nIf everything was successful, this will print the version of radian installed, including the paths to  and python executables and their corresponding versions installed. This is where you may also notice that the manual addition of  to PATH and python‚Äôs automatic addition during installment saves us from future headaches and errors that we my have faced such as here. Radian is just a front-end; it needs  to run, hence it has to be added to PATH.\nMany people prefer using the radian as an alternative Console for . You can configure VS Code to use radian by setting the path to the radian executable in your setting.json. To set radian as your default  terminal in VS Code settings\nFor windows the radian executable should be located in your Python Scripts folder (i.e., \"C:\\Users\\ENTOMOLOGY LAB\\AppData\\Local\\Programs\\Python\\Python314\\Scripts\\radian.exe\"). While on a n a Mac, this is typically \"/usr/local/bin/radian\", while for Linux \"/usr/bin/radian\".\nYou can access settings.json by pressing ‚åò + Shift + P on Mac or Ctrl + Shift + P on Windows/Linux, typing ‚ÄúOpen Settings (JSON)‚Äù, and pressing Enter‚Üµ.\nConfigure VS Code settings\n\nOpen VS Code\nPress Ctrl + space,\nSearch for settings.json.\n\nFor windows add the following line:\n{\n    \"r.term.windows\": \"C:\\\\Users\\\\ENTOMOLOGY LAB\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\Python314\\\\Scripts\\\\radian.exe\"\n}\n\nFor Mac:\n{\n    \"r.term.mac\": \"/usr/local/bin/radian\"\n}\nFor Linux\n{\n    \"r.term.linux\": \"/usr/bin/radian\"\n}\nThe radian terminal provides syntax highlighting, multiline editing, and autocompletion in the console. Standard  terminal lacks these features. Radian makes the interactive  much more usable with modern terminal features.\nThere are a few more recommended VS Code settings for . These settings help to optimize your workflow when working with  in VS Code. You can add these settings in your settings.json file as we did with the radian executable:\n{\n\"r.bracketedPaste\": true,\n\"r.sessionWatcher\": true,\n\"r.alwaysUseActiveTerminal\": true,\n\"r.removeLeadingComments\": true,\n\"r.plot.useHttpgd\": true,\n\"editor.wordWrap\": \"wordWrapColumn\",\n\n\"[r]\": {\n   \"editor.defaultFormatter\": \"REditorSupport.r\"\n},\n\n\"workbench.colorCustomizations\": {\n   //  \"editorError.foreground\": \"#00000000\", // Red Squiggly, I suggest not to change this one‚Ä¶\n   //  \"editorWarning.foreground\": \"#00000000\", // Yellow Squiggly, I suggest not to change this one‚Ä¶\n   \"editorInfo.foreground\": \"#00000000\", // Blue Squiggly, you could even change it yo something almost completely transparent so it doesn‚Äôt bother you as much‚Ä¶\n    }\n\n}\nAn integral part of setting up VS Code for R development is fine-tuning the behavior of the lintr package, which plays a crucial role in maintaining high code quality and adherence to coding standards. By customizing the .lintr configuration, developers can control which linting rules are enforced, tailoring the development environment to their preferences or project-specific guidelines.\nEnhance your R programming experience in VS Code by tweaking some settings in your settings.json file.\nMigrating from RStudio to VS Code for R development not only opens up new possibilities for enhancing your development environment but also requires some adjustments to tailor the experience to your preferences.\nBy following the above steps, you‚Äôve now equipped VS Code with powerful tools and configurations to supercharge your  programming. With the  extension, radian, essential packages, and tailored settings, you‚Äôre all set to enjoy a streamlined, productive coding experience in . Whether you‚Äôre analyzing data, creating visualizations, or developing statistical models, VS Code is now a formidable ally in your  programming endeavors. Happy coding!\nThis is one of the little maintenance chores that comes with upgrading  on Windows is you need to adjust paths.\n\n\n\n3.2.4 ‚Äî A New, Yet Familiar IDE for  and  Python\n\n\n\n\n\n\n\nPositron\n\n\nPositron is a modern, next-generation Integrated Development Environment (IDE) by Posit with data scientists and analysts at its core. It is designed to act as a single, unified workspace for coding, data exploration, visualization, and analysis.\nAt its heart, Positron brings together more than a decade of lessons learned from RStudio, while embracing the flexibility and extensibility of Visual Studio Code. Technically, Positron is built as a fork of Visual Studio Code ( VS Code), meaning it inherits a familiar interface, keyboard shortcuts, and extension support ‚Äî all while introducing workflows tailored specifically for data science.\nUnlike traditional editors that focus on one language at a time, Positron is polyglot by design. Both  and  Python are treated as first-class citizens, allowing users to switch seamlessly between languages within the same project. This makes Positron particularly well-suited for modern data science workflows, where multiple languages are often used side-by-side.\nUnder the hood, Positron is built on Code - OSS, the same open-source foundation that powers VS Code. This gives it access to a rich ecosystem of extensions and tools, while Positron layers on features long familiar RStudio users ‚Äî such as an integrated console, data viewer, and workflow-oriented panels ‚Äî now available to both  and  Python users. In practice, this means you get the flexibility of VS Code without losing the data-centric conveniences that analysts rely on.\nYou can think of Positron as a thoughtful blend of two worlds: the extensibility of VS Code and the data-focused ergonomics of RStudio. If those two IDEs were ever to ‚Äújoin forces,‚Äù Positron would be the natural result.\nPositron should not be confused with RStudio, the classic IDE many users already know. In 2022, RStudio, PBC rebranded as Posit to reflect its broader focus beyond R alone. Positron emerged from this evolution as a new IDE built to support both  and  Python, aligning with the realities of modern data science teams.\nPositron is guided by a few key ideas which form its core design principles:\n\nPolyglot - Work with ,  Python, and other languages in a single, cohesive environment.\nExtensible - Customize and extend Positron using VS Code-compatible extensions available through the Open VSX marketplace.\nAI used responsibly - Leverage AI-assisted tools while maintaining transparency, correctness, and reproducibility in your work.\n\nPositron was introduced as public beta in 2023 and evolved through several iterative releases between 2023 and 2025. During this period, it matured into a stable, cross-platform IDE for data science. Version 2026.01.0-147 marks the first stable release, distributed under the Elastic License 2.0. This makes Positron source-available ‚Äî you can inspect the code ‚Äî but it is not fully open-source in the traditional sense.\n\n3.2.4.1 Hello Positron IDE: Installing \nPositron IDE is available on all major platforms, including Windows, macOS, and Linux. The steps below walk through installing the stable desktop version, suitable for individual users.\n\nDownload Positron\nVisit the official Positron website\nClick Download\nChoose the right Positron edition\nOn the download page, you‚Äôll see two options:\n\nPositron Desktop ‚Äî a free, standalone IDE installed directly on your computer.\nPositron Pro ‚Äî an enterprise-grade version integrated with Posit Workbench, designed for teams that need centralized security, governance, and access to shared computing resources\n\nIf you are learning or working independently, Positron Desktop is the correct choice and is what we‚Äôll use here.\nWindows Prerequisites: Visual C++ Redistributable\nIf you are installing Positron on Windows, one additional requirement is important to check that you have the latest Visual C++ Redistributable installed.\nVisual C++ Redistributable is a Microsoft runtime library that contains essential components needed to run applications built with Visual Studio C++. Positron is partly built using Visual C++ components and without the redistributable, cthe IDE may fail to install or launch, sometimes showing errors such as:\n\nMSVCP140.dll missing\nruntime error.\n\nTo check if the latest Visual C++ is installed:\n\nPress  Windows Key + R to open the Run dialog.\nType appwiz.cpl and press Enter‚Üµ ‚Äî this opens Programs and Features.\nLook for entries such as:\n\nMicrosoft Visual C++ 2015-2022 Redistributable (√ó64)\nMicrosoft Visual C++ 2015-2022 Redistributable (√ó86)\n\n\nIf you see any of these, it means the redistribtable is installed on your platform. The (√ó64) version is the most common on morden systems.\nIf not installed, download the latest version from üëâ link.\nOne the page navigate to the table with links to the apporiate section. click on the latest versions link.\nYou need to download the appropriate Visual Studio C++ for your systems architecture. To check Your Windows Architecture\n\nPress  Windows Key + I to open Settings.\nGo to System About.\nLook for System type.\n\n\nIf it says 64-bit operating system, √ó64-based processor, you need the √ó64 redistributable.\nIf it says 64-bit operating system, ARM-based processor, you need the ARM64 redistributable.\n(Rarely, if it says 32-bit operating system, you‚Äôd need the √ó86 redistributable, but most modern systems are √ó64 or ARM64.)\n\nClick on the appropriate installer link for your architecture. After the ownload is complete double click the installer and install it like any application. You will have to restart your computer was the installation is complete\nDownload the Positron installer\nOnce prerequisites are met, return to the Positron download page, check the license agreement box, and download the download the installer for your platform.\nOn Windows, you‚Äôll be offered two installer types: the system level install and user level install installer options. If you‚Äôre the only person using the computer and you have admin rights System-level is simpler and more standard. If you‚Äôre on a work/school computer without admin rights, or you want to keep things isolated User-level is the safer choice. Both versions of Positron are functionally the same ‚Äî it‚Äôs just about installation scope and permissions."
  },
  {
    "objectID": "posts/intro-to-r/index.html#programming-basics-and-fundamentals",
    "href": "posts/intro-to-r/index.html#programming-basics-and-fundamentals",
    "title": "An Introduction to R",
    "section": "4  Programming Basics and Fundamentals",
    "text": "4  Programming Basics and Fundamentals\nAfter a likely tedious installation of  and an IDE such as RStudio, VS Code or Positron, as well as a detailed familiarization with their interfaces, We are now ready to do a little more coding and explore the fundamentals of  programming.\nIn this section, we introduce the core building blocks of  programming. These fundamentals form the foundation for everything you will do in , from simple calculations to more advanced analyses. Developing a strong understanding of these basics early on will make your earning experience smoother and more intuitive as you progress to topics such as data manipulation, visualization, and statistical modeling.\nIt can be tempting to skim or skip over these early technical details, especially if they feel abstract at first. However, these concepts quietly underpin much of what comes later in . Taking the time to understand them now will save you confusion and frustration down the line, when small misunderstandings can lead to puzzling errors in more complex workflows.\n\n4.1 Commands, Expressions, Assignments, Operators, and Objects\nAt this point, you have already written your first \"Hello, World!\" program and performed some basic arithmetic in , much like using a handheld calculator. You have also learned why organizing code into scripts is essential for reproducibility. Here, we build directly on this acquired knowledge by introducing the core concepts that govern how  evaluates and executes code.\nA command in  is an instruction you give to the interpreter. Most commands are expressions, meaning they are pieces of code that  evaluates to produce a result.\nAs earlier discussed, the simplest expressions in  are arithmetic operations.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nClick Run Code to execute the examples.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nMost of these operations behave exactly as expected. However, one notable difference is that there is no square-root symbol in . Instead, {fa brands r-project} uses functions such as sqrt() to compute roots.\nWhen you run these expressions, , R evaluates them and prints the result to the Console. If you type them into a script and click Run (or press Ctrl + Enter‚Üµ the same evaluation happens line by line.\nYou may notice that each printed result with [1]. This indicates the position (index) of the first element in the output. While this may seem odd now, it will make much more sense once we discuss vectors and indexing later on.\nAt this stage, the output results produced by your commands above are only temporary‚Äîonce printed to the screen, they are lost (i.e., they are not stored anywhere). In order to perform anything beyond trivial calculations, you must be able to store results and reuse them when the need arises. In  this is done through assignment.\nAn assignment takes the result of an expression and stores it as an object, using the assignment operator &lt;-. The = operator can also be used for assignments, but it is less preferred for this purpose. Instead, it is mainly used for specifying arguments inside function calls. When an expression is assigned to an object, its value is no longer printed automatically to the Console.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nRun the object name x to display its stored value.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nYou can also explicitly use the print() function to display output.\n\nOnce assigned, x becomes an object in your workspace. Objects are central to ‚Äîthey are how data, results, functions, and models are represented and manipulated.\n\n\n\nIn  almost everything is an object.\n\nBe careful with spacing when using operators. for example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis code does not assign a value to x. Instead, because of the space between the two characters that make up the assignment operator,  interprets &lt; as a logical comparison operator, that asks if x is less than -1 + 1 (i.e., zero). Although R generally ignores extra spaces, spaces must not split operators or object names. This, for example, is perfectly valid:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nOne important caveat to keep in mind is that  silently overwrites any previous information stored in an object when you assign a new value to the same object name. For this reason, it‚Äôs a good practice to avoid reusing object names unless you intentionally want to replace their contents.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNotice the value stored in object y changes because the second assignment replaces the first one.\n\nIn RStudio, assigned objects appear in the Environment pane (top right).\nIn VS Code and Positron, similar workspace panels show stored objects as below:\nYou can also list all stored objects programatically using:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nTo remove an object from the workspace, use rm() or remove():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nAttempting to access a removed object results in an error.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nremove() can also be used to remove a stored object from the workspace.\n\nTo remove all existing objects from the workspace, which is often recommended when starting a new analysis workflow, you can use the following command:\n\nrm(list = ls())\n\nls()\n\n\n\n\nls() lists all objects currently in the workspace.\nrm() removes objects.\nrm(list = ls()) removes everything that ls() finds.\nRunning ls() afterward confirms that the workspace is empty.\n\nThis helps ensure that your analysis starts from a clean environment and is not influenced by leftover objects from previous work.\nIf you want to assign the same value to multiple objects in a single statement:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n is a case-sensitive language. This applies to object names, function names, and other identifiers in . If you create an object using a lowercase name, referring to it with a different case will result in an error.\nFor example, if an object is assigned to lowercase x, attempting to access it using uppercase X will give an error:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSimilarly, function names must use the exact correct casing:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn , commands can be separated in two ways:\n\nBy starting a new line (i.e., hitting Enter‚Üµ) or\nBy using a semicolon ;\n\nUsing semicolons can be useful for condensing code in scripts, although placing each command on its own line is generally clearer and more readable. If a command is incomplete on a line, either by design or due to a syntax error, the Console prompt changes from &gt; to +, indicating that  is waiting for additional input before it can evaluate the command.\nBesides arithmetic operations there are also logical queries you can perform. Logical queries always evaluate either TRUE or FALSE. Here are a few examples to illustrate this.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nBabu is a Hindu honorific to show respect or endearment.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nMasoyiyata is a Hausa term of endearment meaning \"my love\" or \"my beloved\".\n\nLogical comparisons play a crucial role in filtering data, making decisions, and controlling program flow.\nThe  language provides a rich set of operators including those for arithmetic, comparison, logical evaluation, indexing, and model specification. The interactive table below summarizes some of the most commonly used operators. Feel free to explore them and their example usages.\n\n\n\n\n\n\n¬†\nTo bring everything together, commands in  operate on objects. An object is anything that can be assigned a name using the assignment operator &lt;-. Objects can store values, data, or even behavior.\nCommon object types include vectors, matrices, factors, lists, data frames, and functions. With the exception of functions, these are often referred to as data structures or data objects. Each object type behaves differently, and operators interact with them in specific ways.\nUnderstanding how objects are created, stored, and manipulated, and how operators act on them, is central to effective  programming. This foundation prepares you to work confidently with data types and data structures, which we explore next.\n\n\n4.2  Data types\nA \"data type\" describes the kind of values stored in an object, not the structure that holds them. For example, a vector, data frame or list can store different data types. In , the most commonly encountered data types are numeric, character, logical, and complex. These basic types are sometimes referred to as modes.\nNumeric data represent numbers and are used in calculations.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nBy default, numbers in  are stored as numeric (double-precision) values. There is also an integer type, which we revisit later, but for most practical purposes numeric values behave the same in calculations.\nCharacter data are used to store text.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nWhen you enter character data directly in , you must enclose individual elements with either single or double quotes. If quotes are omitted,  assumes you are referring to an existing object.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nAn error occurs because John is interpreted as an object name rather than text.\n\n\nSingle or double quotes are interchangeable but they must be used consistently. When character data are imported from files such as CSVs, quotes are typically handled automatically and do not need to be added manually.\nLogical data represent truth values and can take only three possible values: TRUE, FALSE, and NA. The value NA indicates missing data, which is handled explicitly in {&lt; fa brands r-project &gt;}.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNote that logical values are not enclosed in quotes. Quoting them would convert them to character data.\nThe same is also true for numeric values.\n\nAlthough  recognizes T and F as short forms for TRUE and FALSE respectively, these are not reserved keywords and can therefore be reassigned by the user. For this reason, it is generally safer to use the full logical values.\nAs already illustrated in the previous section, logical values often arise as the result of comparisons and relational expressions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nComplex numbers consist of a real and an imaginary part and are written using i to denote the imaginary unit.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nComplex data are less common in everyday data analysis, but they are supported natively by \nYou can examine the type of data stored in an object using the class() or mode() functions.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe class() function is generally preferred in modern  programming because it reflects how objects behave in practice, especially for more complex data structures. The mode() function reports the underlying storage type and is mostly useful for low-level inspection.\nIn , you can also whether an object belongs to a particular data type using logical test functions. These functions follow the pattern is.&lt;class&gt;() fand always return either TRUE or FALSE, depending on the class of the object being tested.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nLogical tests are especially useful when writing code that needs to behave differently depending on the type of data it receives. They help you confirm your assumptions about objects before performing further operations.\nIn addition to testing data types, it can sometimes be useful to be able to change the class of an object.  allows you to change the class of an object using coercion functions. These functions follow the pattern as.&lt;class&gt;().\nWhile coercion can be very useful, it should be used with care. Converting objects between classes does not always work as expected, particularly when the original data cannot be meaningfully represented in the new type.\nLet us start by checking the class of x:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCoercing numeric values to character\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNotice that the number is now treated as text and appears enclosed in quotation marks.\n\nIn this case, the conversion is straightforward. Numeric values can always be represented as character strings, so no information is lost.\nNow consider the opposite direction:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNA values are introduced because the character strings in name cannot be interpreted as valid numbers.\n\nWhen  encounters characters that cannot be converted into numeric values, it replaces them with NA and issues a warning. This behavior highlights why coercion should be done carefully, especially when working with real-world data.\nThe table below summarizes some commonly used logical test functions and their corresponding coercion functions in  .\n\n\n\n\n\n\n\n\nType\nLogical test\nCoercing\n\n\n\n\nCharacter\nis.character()\nas.character()\n\n\nNumeric\nis.numeric()\nas.numeric()\n\n\nLogical\nis.logical()\nas.logical()\n\n\nFactor\nis.factor()\nas.factor()\n\n\nComplex\nis.complex()\nas.complex()\n\n\n\n\n\n\n\n\n\n\nAlways test a variable‚Äôs class before coercing it, especially when working with imported data.\n\n\n\n4.3  Data structures\nIn , data are stored in data structures, sometimes also called data objects. These are the containers that hold your data and that you perform operations on, such as calculations, plotting and statistical analysis. Every object you create in  exists in one of these structures.\nThe most common data structures in  are vectors, matrices, arrays, data frames, lists, and factors. Each has a specific purpose and is suited to different kinds of tasks. In later sections, you will learn how to work with them in more depth. For now, the goal is to understand what they look like and how they differ.\nVectors are perhaps the most fundamental data structure in . A vector is an ordered collection of elements, such as numbers, characters, or logical values.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n1:12 creates a sequence of integers from 1 to 12.\nAll elements in a vector must be of the same data type.\n\nVectors are the building blocks for many other data structures.\nMatrices are similar to vectors, but they have two dimensions, rows and columns. Like vectors, matrices can only store one type of data at a time.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe matrix() function reshapes a vector into rows and columns.\nnrow = 3 tells  how many rows the matrix should have.\nValues are filled column by column by default.\n\nArrays extend the idea of matrices by allowing more than two dimensions. They are useful when working with multidimensional data.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\ndim = c(2, 5, 3) defines rows, columns, and layers.\nArrays still store only one data type.\n\nArrays are less common for beginners but appear in advanced applications.\nVectors, matrices, and arrays share the same rule: they can only store one data type at a time. This means that all elements must be numeric, character, or logical. This property is often referred to as having a single mode.\nData frames are one of the most commonly used data structures in . Like matrices, they are two-dimensional, but unlike matrices, each column can store a different data type.\nData frames resemble tables used in spreadsheets or other statistical software. Each column typically represents a variable, and each row usually represents an ‚Äúobservation‚Äù, or ‚Äúrecord‚Äù, or ‚Äúexperimental unit‚Äù.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nEach column is a vector of the same length.\nDifferent columns can have different data types.\nData frames are central to data analysis in .\n\nLists are flexible data structures that can store different types of objects, including other data structures. Unlike vectors, list elements do not need to be the same type or size.\nLists often appear as the output of functions, especially more complex ones.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nA list can contain numbers, vectors, matrices, and data frames.\nElements inside a list can have different structures.\n\nLists are essential for handling complex results.\nA data structure does not need to contain data in order to exist. You can create an empty object using NULL. This can be useful when you want to prepare a container that will be filled later.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNULL represents the absence of data.\nEmpty objects are often used in programming and iterative workflows.\n\nUnderstanding data structures is essential for effective  programming. The way data are stored determines how they behave when you manipulate them, how functions interact with them, and how results are returned. As you progress, you will see that most errors and unexpected behavior in R can be traced back to misunderstandings about data structures."
  },
  {
    "objectID": "posts/intro-to-r/index.html#unlocking-s-hidden-power-getting-started-with-packages",
    "href": "posts/intro-to-r/index.html#unlocking-s-hidden-power-getting-started-with-packages",
    "title": "An Introduction to R",
    "section": "5 Unlocking ‚Äôs Hidden Power: Getting Started with  Packages",
    "text": "5 Unlocking ‚Äôs Hidden Power: Getting Started with  Packages\n packages"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I‚Äôm Elias Nelson.",
    "section": "",
    "text": "Back to top"
  },
  {
    "objectID": "gallery/gallery.html",
    "href": "gallery/gallery.html",
    "title": " Gallery",
    "section": "",
    "text": "Explore my interactive Visualizations"
  },
  {
    "objectID": "gallery/gallery.html#interactive-charts",
    "href": "gallery/gallery.html#interactive-charts",
    "title": " Gallery",
    "section": "",
    "text": "Explore my interactive Visualizations"
  },
  {
    "objectID": "gallery/gallery.html#day-map-challenge",
    "href": "gallery/gallery.html#day-map-challenge",
    "title": " Gallery",
    "section": "30 Day Map Challenge",
    "text": "30 Day Map Challenge\nThe 30 Day Chart Challenge is a global challenge held every April and invites data analysts and visualization enthusiasts to create a chart every day for 30 days. Each day has a different theme or chart type, encouraging creativity, data exploration and practicing analysis and design techniques.\n\n Explore my code"
  },
  {
    "objectID": "gallery/gallery.html#tidy-tuesday",
    "href": "gallery/gallery.html#tidy-tuesday",
    "title": " Gallery",
    "section": "Tidy Tuesday",
    "text": "Tidy Tuesday\n\n See Code"
  },
  {
    "objectID": "gallery/gallery.html#inforgraphics",
    "href": "gallery/gallery.html#inforgraphics",
    "title": " Gallery",
    "section": "Inforgraphics",
    "text": "Inforgraphics\n\n See Code\n\n‚õèÔ∏è‚õèÔ∏è‚õèÔ∏è"
  },
  {
    "objectID": "gallery/gallery.html#d-shaded-relief-maps",
    "href": "gallery/gallery.html#d-shaded-relief-maps",
    "title": " Gallery",
    "section": "3D Shaded Relief Maps",
    "text": "3D Shaded Relief Maps\n\n See Code\n\n\n\n\n\n\nNyika National Park‚ÄîMalawi\n\n\n\n\n\n\n\nKasungu National Park‚ÄîMalawi"
  },
  {
    "objectID": "gallery/gallery.html#d-population-density",
    "href": "gallery/gallery.html#d-population-density",
    "title": " Gallery",
    "section": "3D Population Density",
    "text": "3D Population Density\n\n See Code"
  },
  {
    "objectID": "posts/blog.html",
    "href": "posts/blog.html",
    "title": " Posts",
    "section": "",
    "text": "An Introduction to R\n\n      \n\n        \n          \n          Sep 23, 2024 ‚Ä¢\n          \n          118 min\n        \n        \n        \n        \n        \n          \n          \n            R\n          \n            Code\n          \n            Analysis\n          \n            Programming\n          \n        \n\n        \n      \n    \n  \n\n\nNo matching items\n Back to top"
  },
  {
    "objectID": "software/r-packages/greekElectionsR/index.html",
    "href": "software/r-packages/greekElectionsR/index.html",
    "title": "greekElectionsR",
    "section": "",
    "text": "Back to top"
  }
]